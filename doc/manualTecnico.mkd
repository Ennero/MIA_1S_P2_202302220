# Manual T√©cnico - Proyecto 1
## Objetivos
### Objetivo General
- Describir detalladamente la implementaci√≥n, arquitectura, estructuras de datos y l√≥gica de funcionamiento del simulador de sistema de archivos EXT2, facilitando su comprensi√≥n, uso y mantenimiento futuro en el contexto del curso de Manejo e Implementaci√≥n de Archivos.
### Objetivos Espec√≠ficos
- Explicar en detalle las estructuras de datos clave que simulan los componentes de un disco y un sistema de archivos EXT2 (MBR, Particiones, EBR, SuperBloque, Inodos, Bloques de Datos/Carpetas/Punteros, Bitmaps).
- Presentar la arquitectura Cliente-Servidor utilizada (Frontend Vue.js y Backend Go).
- Detallar el proceso de serializaci√≥n y deserializaci√≥n de estas estructuras hacia/desde un archivo binario que representa el disco virtual.

## Alcances del Sistema
Este sistema simula la creaci√≥n y gesti√≥n de discos virtuales y sistemas de archivos basados en la estructura EXT2. El alcance funcional incluye:

### Gesti√≥n de Discos
- Creaci√≥n de discos virtuales (mkdisk) con tama√±o y ajuste especificados (BF, FF, WF).
- Eliminaci√≥n de discos virtuales (rmdisk).

### Gesti√≥n de Particiones
- Creaci√≥n de particiones Primarias (fdisk -type=P).
- Creaci√≥n de partici√≥n Extendida (fdisk -type=E) (m√°ximo una por disco).
- Creaci√≥n de particiones L√≥gicas (fdisk -type=L) dentro de la Extendida, utilizando EBRs encadenados.

### Montaje
- Montaje de particiones Primarias y L√≥gicas (mount) asignando un ID √∫nico.
- Listado de particiones montadas (mounted).

### Formateo
- Creaci√≥n de un sistema de archivos EXT2 (mkfs) en una partici√≥n montada, incluyendo:
  - C√°lculo de n√∫mero de inodos y bloques (n).
  - Escritura del SuperBloque.
  - Inicializaci√≥n de Bitmaps de Inodos y Bloques.
  - Creaci√≥n del Inodo ra√≠z (/).
  - Creaci√≥n del archivo /users.txt con el usuario root inicial.


### Gesti√≥n de Usuarios y Grupos 
- Inicio de sesi√≥n (login) validando contra /users.txt.
- Cierre de sesi√≥n (logout).
- Creaci√≥n de grupos (mkgrp).
- Eliminaci√≥n de grupos (rmgrp) (excepto root).
- Creaci√≥n de usuarios (mkusr) asignados a un grupo existente.
- Eliminaci√≥n de usuarios (rmusr) (excepto root).
- Cambio de grupo para un usuario (chgrp).

### Gesti√≥n de Archivos y Directorios
- Creaci√≥n de directorios (mkdir), incluyendo creaci√≥n recursiva de padres (-p).
- Creaci√≥n de archivos (mkfile), con contenido opcional desde tama√±o (-size) o archivo local (-cont), y creaci√≥n recursiva de padres (-r). Soporta indirecci√≥n simple y doble (triple pendiente).
- Visualizaci√≥n de contenido de archivos (cat).

### Generaci√≥n de Reportes
- Generaci√≥n de reportes gr√°ficos (rep) usando Graphviz sobre: MBR (mbr), Disco (disk), SuperBloque (sb), Bitmaps (bm_inode, bm_block), Tabla de Inodos (inode), Bloques Usados (block), √Årbol de Directorios/Archivos (tree), Contenido de Archivo (file), Listado tipo ls -l (ls).


## Especificaciones t√©cnicas
### Requisitos de Hardware
- **Memoria RAM:** 2GB (Recomendado 4GB+ para ejecuci√≥n fluida, especialmente con discos grandes).
- **Espacio en Disco:** 1GB libre (para el c√≥digo fuente, Go, Node.js, y los discos virtuales generados).

- **Procesador:** 1GHz x64 o superior.
- Pantalla
- Teclado
- Mouse (opcional)
### Requisitos de Software 
- **Sistema Operativo:** Compatible con Go y Node.js (Linux [Mint/Ubuntu recomendado], macOS, Windows).
- **Go:** Versi√≥n 1.18 o superior
- **Node.js:** Versi√≥n LTS recomendada (Verificar con node -v). Incluye npm.
- **Vue CLI:** (Si se usa para gestionar el frontend Vue)
- **Graphviz:** Necesario para generar los reportes gr√°ficos. Debe estar instalado y el comando dot accesible desde el PATH del sistema (Verificar con dot -V).
- **IDE/Editor:** Visual Studio Code (recomendado) con extensiones para Go y Vue.js, u otro editor/IDE de preferencia.
- **Terminal/Consola:** Para compilar y ejecutar el backend/frontend.

### Descripci√≥n de la arquitectura del programa
El sistema sigue una arquitectura **Cliente-Servidor** desacoplada:

#### Frontend
- Tecnolog√≠a: Desarrollado con Vue.js (Framework progresivo de JavaScript).
- Interfaz: Una aplicaci√≥n de p√°gina √∫nica (SPA) que presenta una interfaz similar a una consola.
  - √Årea de texto para ingresar comandos manualmente o cargar desde archivo .mias.
  - Botones para "Cargar Archivo", "Ejecutar" y "Limpiar".
  - √Årea de texto (solo lectura) para mostrar la salida de los comandos y mensajes del sistema.
- Comunicaci√≥n: Se comunica con el backend a trav√©s de peticiones HTTP (espec√≠ficamente POST) a una API REST definida por el backend. Env√≠a los comandos como un string dentro de un objeto JSON { "command": "..." }. Recibe las respuestas del backend (salida o errores) tambi√©n en formato JSON.
- Flujo: El frontend es responsable de la interacci√≥n con el usuario.
  - **Vista principal:** Permite la validaci√≥n b√°sica de entrada (ej. extensi√≥n .mias), y la presentaci√≥n de resultados. Env√≠a los comandos l√≠nea por l√≠nea al backend para su procesamiento. En la parte inferior, la consola muestra los resultados de los comandos ejecutados y proporciona informaci√≥n sobre el estado del sistema de archivos.
```vue
<script>
export default {
    data() {
        return {
            entrada: "",
            salida: "",
            fileError: ""
        };
    },
    methods: {
        handleFileUpload(event) {
            const file = event.target.files[0];
            this.fileError = "";

            if (!file) return;

            const fileName = file.name;
            const fileExtension = fileName.split('.').pop().toLowerCase();

            if (fileExtension !== 'mias') {
                this.fileError = "Solo se permiten archivos con extensi√≥n .mias";
                event.target.value = '';
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                this.entrada = e.target.result;
                this.salida = `‚úÖ Archivo cargado: ${fileName}\n--- Contenido ---\n${this.entrada}\n---------------\nListo para ejecutar.`; // Mostrar contenido cargado
            };
            reader.readAsText(file);
        },
        async ejecutar() { // Marcar la funci√≥n como async
            if (!this.entrada.trim()) {
                this.salida = "‚ö†Ô∏è No hay comandos para ejecutar";
                return;
            }

            // Limpiar salida anterior e indicar inicio
            this.salida = "üîÑ Ejecutando comandos...\n------------------------\n";

            // Dividir la entrada en l√≠neas
            const lines = this.entrada.split('\n');
            let hasErrors = false; // Para rastrear si hubo alg√∫n error

            // Iterar sobre cada l√≠nea
            for (const line of lines) {
                const trimmedLine = line.trim(); // Quitar espacios inicio/fin

                if (trimmedLine === "" || trimmedLine.startsWith("#")) {
                    continue; // Pasar a la siguiente l√≠nea
                }

                // Mostrar el comando que se va a ejecutar
                this.salida += `> ${trimmedLine}\n`;

                try {
                    const response = await fetch('http://localhost:3001/', { // Usar await para esperar la respuesta
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        // Enviar solo la l√≠nea actual como comando
                        body: JSON.stringify({ command: trimmedLine }),
                    });

                    // Leer la respuesta del backend
                    const data = await response.json(); // Usar await

                    // Verificar si el backend report√≥ un error en su estructura JSON
                    if (data.error) {
                        this.salida += `‚ùå Error: ${data.error}\n`;
                        hasErrors = true;
                    } else if (!response.ok) {
                        let errorMsg = `Error HTTP ${response.status}`;
                        if (data.output) { // Si hay 'output' aunque no sea OK, podr√≠a tener el error
                            errorMsg += `: ${data.output}`;
                        } else if (data.error) { // O si hay campo 'error'
                            errorMsg += `: ${data.error}`;
                        }
                        this.salida += `‚ùå ${errorMsg}\n`;
                        hasErrors = true;
                    } else {
                        if (data.output && data.output.trim() !== "") {
                            this.salida += `${data.output}\n`;
                        } else {
                            this.salida += `(OK)\n`;
                        }
                    }
                } catch (error) {
                    console.error("Error en fetch:", error);
                    this.salida += `‚ùå Error de conexi√≥n o respuesta inv√°lida del backend.\n`;
                    hasErrors = true;
                }
                this.salida += "------------------------\n";
            }

            this.salida += hasErrors ? "‚ö†Ô∏è Ejecuci√≥n completada con errores." : "‚úÖ Ejecuci√≥n completada.";

        },
        limpiar() {
            this.entrada = "";
            this.salida = "";
            this.fileError = "";
            const fileInput = document.getElementById('fileInput');
            if (fileInput) fileInput.value = '';
        },

        //Aqu√≠ se va a inicar sesi√≥n

        iniciarSesion() {
            console.log("Redirigiendo a inicio de sesi√≥n...");
            const url = "/login"; // URL de inicio de sesi√≥n
            this.$router.push(url); // Redirigir a la URL de inicio de sesi√≥n
        }
    },
};
</script>
```
![1](./img/1.png)


  - **Vista Login:** Permite loguearse sin necesidad de usar la consola.
```vue
<script>
export default {
  name: 'UserLogin',
  data() {
    return {
      loginForm: {
        idPartition: '',
        username: '',
        password: '',
      },
      statusMessage: '',
      errorMessage: ''
    }
  },
  methods: {
    async handleLogin() { // Marcar como async para usar await
      this.errorMessage = "";
      this.statusMessage = "Validando credenciales...";
      console.log('Intentando iniciar sesi√≥n con:', this.loginForm);

      if (!this.loginForm.idPartition || !this.loginForm.username || !this.loginForm.password) {
        this.errorMessage = "Todos los campos son obligatorios.";
        this.statusMessage = "";
        return;
      }

      // Construir el string del comando login
      const commandString = `login -user=${this.loginForm.username} -pass=${this.loginForm.password} -id=${this.loginForm.idPartition}`;

      console.log("Enviando comando:", commandString);

      try {
        const response = await fetch('http://localhost:3001/', { // URL del backend
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ command: commandString }), // Enviar el comando como lo espera el backend
        });

        const data = await response.json(); // Esperar y parsear la respuesta JSON

        if (!response.ok || data.error) {
          // Hubo un error HTTP o el backend report√≥ un error espec√≠fico
          const errorMsg = data.error || data.output || `Error HTTP ${response.status}`;
          this.errorMessage = `Error de inicio de sesi√≥n: ${errorMsg}`;
          this.statusMessage = ""; // Limpiar mensaje de estado
          console.error("Error en login desde backend:", errorMsg);
        } else {
          // Login v√°lido en el backend
          this.statusMessage = "¬°Inicio de sesi√≥n exitoso! Redirigiendo...";
          console.log("Login successful:", data.output); // Mostrar mensaje del backend (si lo hay)

          setTimeout(() => {
            this.$router.push('/loged'); // Redirigir a la vista de disco despu√©s de 1 segundo
          }, 1000); // Espera 1 segundo antes de redirigir

        }

      } catch (error) {
        // Error de red (backend no disponible, CORS, etc.) o error parseando JSON
        console.error("Error en fetch durante login:", error);
        this.errorMessage = "Error de conexi√≥n con el servidor. Aseg√∫rate de que el backend est√© corriendo.";
        this.statusMessage = "";
      }
    },
    volverAConsola() {
      console.log("Volviendo a la consola...");
      this.$router.push('/'); // Navegar a la ruta ra√≠z
    }
  }
}
</script>
```
![3](./img/3.png)

  - **Vista loged:** Muestra la vista principal con funciones extras al estar logueado.

```vue
<script>
export default {
    data() {
        return {
            entrada: "",
            salida: "",
            fileError: ""
        };
    },
    methods: {
        handleFileUpload(event) {
            const file = event.target.files[0];
            this.fileError = "";

            if (!file) return;

            const fileName = file.name;
            const fileExtension = fileName.split('.').pop().toLowerCase();

            if (fileExtension !== 'mias') {
                this.fileError = "Solo se permiten archivos con extensi√≥n .mias";
                event.target.value = '';
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                this.entrada = e.target.result;
                this.salida = `‚úÖ Archivo cargado: ${fileName}\n--- Contenido ---\n${this.entrada}\n---------------\nListo para ejecutar.`; // Mostrar contenido cargado
            };
            reader.readAsText(file);
        },
        async ejecutar() { // Marcar la funci√≥n como async
            if (!this.entrada.trim()) {
                this.salida = "‚ö†Ô∏è No hay comandos para ejecutar";
                return;
            }

            // Limpiar salida anterior e indicar inicio
            this.salida = "üîÑ Ejecutando comandos...\n------------------------\n";

            // Dividir la entrada en l√≠neas
            const lines = this.entrada.split('\n');
            let hasErrors = false; // Para rastrear si hubo alg√∫n error

            // Iterar sobre cada l√≠nea
            for (const line of lines) {
                const trimmedLine = line.trim(); // Quitar espacios inicio/fin

                if (trimmedLine === "" || trimmedLine.startsWith("#")) {
                    continue; // Pasar a la siguiente l√≠nea
                }

                // Mostrar el comando que se va a ejecutar
                this.salida += `> ${trimmedLine}\n`;

                try {
                    const response = await fetch('http://localhost:3001/', { // Usar await para esperar la respuesta
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        // Enviar solo la l√≠nea actual como comando
                        body: JSON.stringify({ command: trimmedLine }),
                    });

                    // Leer la respuesta del backend
                    const data = await response.json(); // Usar await

                    // Verificar si el backend report√≥ un error en su estructura JSON
                    if (data.error) {
                        this.salida += `‚ùå Error: ${data.error}\n`;
                        hasErrors = true;
                    } else if (!response.ok) {
                        let errorMsg = `Error HTTP ${response.status}`;
                        if (data.output) { // Si hay 'output' aunque no sea OK, podr√≠a tener el error
                            errorMsg += `: ${data.output}`;
                        } else if (data.error) { // O si hay campo 'error'
                            errorMsg += `: ${data.error}`;
                        }
                        this.salida += `‚ùå ${errorMsg}\n`;
                        hasErrors = true;
                    } else {
                        if (data.output && data.output.trim() !== "") {
                            this.salida += `${data.output}\n`;
                        } else {
                            // Si no hay output, al menos indicar que se complet√≥ ok (opcional)
                            this.salida += `(OK)\n`;
                        }
                    }
                } catch (error) {
                    // Error de red o al parsear JSON
                    console.error("Error en fetch:", error);
                    this.salida += `‚ùå Error de conexi√≥n o respuesta inv√°lida del backend.\n`;
                    hasErrors = true;
                }
                this.salida += "------------------------\n";
            }

            this.salida += hasErrors ? "‚ö†Ô∏è Ejecuci√≥n completada con errores." : "‚úÖ Ejecuci√≥n completada.";

        },
        limpiar() {
            this.entrada = "";
            this.salida = "";
            this.fileError = "";
            const fileInput = document.getElementById('fileInput');
            if (fileInput) fileInput.value = '';
        },

        //Aqu√≠ se va a cerrar la sesi√≥n
        async cerrarSesion() {
            console.log("Cerrando sesi√≥n...");
            this.salida = "Cerrando sesi√≥n..."; // Feedback visual

            const commandString = "logout"; // Comando para el backend

            try {
                // Llamar al backend para que cierre sesi√≥n 
                const response = await fetch('http://localhost:3001/', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ command: commandString }),
                });
                const data = await response.json();
                // Mostrar resultado del logout del backend (opcional)
                if (data.error) { console.error("Error backend en logout:", data.error); }
                else { console.log("Logout backend:", data.output || "(OK)"); this.$router.push('/'); // Ir a la p√°gina de inicio (no logueado)
            }
            } catch (error) {
                // Error de red, pero continuamos con el logout del frontend
                console.error("Error fetch en logout:", error);
                this.salida += "\nError de conexi√≥n al cerrar sesi√≥n en backend, cerrando localmente.";
            }
        },
        async Disks() {
            console.log("Redirigiendo a discos...");
            const url = "/disk"; // URL de inicio de sesi√≥n
            this.$router.push(url); // Redirigir a la URL de inicio de sesi√≥n

        }
    },
};
</script>
```
![4](./img/4.png)

  - **Vista disks:** Muestra todos los discos creados y permite ingresar en estos.
```vue
<script>
export default {
    name: 'DiskPage',
    data() {
        return {
            disks: [],
            isLoading: false,
            errorMessage: ''
        };
    },
    methods: {
        // M√©todo para obtener la info de discos del backend
        async fetchDisks() {
            this.isLoading = true;
            this.errorMessage = '';
            this.disks = [];
            console.log("Enviando comando 'disks' al backend...");

            try {
                const response = await fetch('http://localhost:3001/', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ command: "disks" }),
                });

                const data = await response.json();

                if (!response.ok || data.error) {
                    const errorMsg = data.error || data.output || `Error HTTP ${response.status}`;
                    throw new Error(`Error obteniendo lista de discos: ${errorMsg}`);
                }

                console.log("Respuesta recibida:", data.output);
                //alert("Respuesta recibida: " + data.output);
                this.parseAndSetDisks(data.output); // Llamar al parser

            } catch (error) {
                console.error("Error en fetchDisks:", error);
                this.errorMessage = error.message || "Error de conexi√≥n o respuesta inv√°lida.";
            } finally {
                this.isLoading = false;
            }
        },

        parseAndSetDisks(outputString) {
            if (!outputString || typeof outputString !== 'string') {
                console.warn("String de salida inv√°lido:", outputString);
                this.errorMessage = "Respuesta inv√°lida del servidor (no es string).";
                this.disks = [];
                return;
            }
            const prefix = "DISKS:\n";
            if (!outputString.startsWith(prefix)) {
                console.warn("String de salida sin prefijo esperado:", outputString);
                this.errorMessage = "Respuesta inv√°lida del servidor (formato inesperado).";
                this.disks = [];
                return;
            }

            // Usar slice para quitar prefijo 
            let dataString = outputString.slice(prefix.length);

            if (dataString.trim() === "") {
                console.log("No hay discos registrados seg√∫n el backend.");
                this.disks = [];
                return;
            }

            // Separar por punto y coma y quitar espacios
            const diskEntries = dataString.split(';');
            const parsedDisks = [];

            // Iterar sobre cada disco
            for (const entry of diskEntries) {
                const trimmedEntry = entry.trim();
                if (trimmedEntry === "") continue;

                const fields = trimmedEntry.split(',');
                if (fields.length !== 5) {
                    console.warn("Entrada de disco con formato incorrecto (campos != 5), saltando:", entry);
                    continue;
                }

                const diskName = fields[0].trim();
                const diskPath = fields[1].trim();
                //alert(`Path del disco: ${diskPath}`);
                const diskSizeStr = fields[2].trim();
                //alert(`Tama√±o del disco: ${diskSizeStr}`);
                const diskFit = fields[3].trim();
                //alert(`Ajuste del disco: ${diskFit}`);
                const mountedStr = fields[4].trim();
                //console.log("Particiones montadas:", mountedStr);

                // Usar parseInt y isNaN ---
                const diskSize = parseInt(diskSizeStr, 10); // Base 10
                if (isNaN(diskSize)) {
                    console.warn(`Tama√±o inv√°lido (no es n√∫mero) para disco '${diskName}', saltando:`, diskSizeStr);
                    continue;
                }
                //alert(`Tama√±o del disco: ${diskSize}`);

                // Parsear particiones montadas
                let mountedPartitions = [];
                if (mountedStr !== "Ninguna" && mountedStr !== "") {
                    mountedPartitions = mountedStr.split('|');
                    for (let i = 0; i < mountedPartitions.length; i++) {
                        mountedPartitions[i] = mountedPartitions[i].trim();
                    }
                }

                if (mountedPartitions.length === 0) {
                    mountedPartitions = "Ninguna";
                }
                parsedDisks.push({
                    name: diskName,
                    path: diskPath,
                    size: diskSize,
                    fit: diskFit,
                    mountedPartitions: mountedPartitions
                });
            }

            this.disks = parsedDisks;
            console.log("Discos parseados:", this.disks);
        },

        selectDisk(disk) {
            console.log("Disco seleccionado, navegando a particiones:", disk);
            if (!disk || !disk.path) {
                console.error("Datos de disco inv√°lidos para navegar.");
                this.errorMessage = "No se puede mostrar particiones para este disco.";
                return;
            }
            try {
                // Codificar el path del disco para pasarlo como par√°metro en la URL
                const encodedPath = encodeURIComponent(disk.path);
                //alert(disk.path)
                // Navegar a la nueva ruta 'PartitionPage', pasando el path codificado
                this.$router.push({ name: 'partitions', params: { diskPathEncoded: encodedPath } });
            } catch (e) {
                console.error("Error en codificaci√≥n de URL o navegaci√≥n:", e);
                this.errorMessage = "No se pudo navegar a la vista de particiones.";
            }
        },

        regresar() {
            console.log("Volviendo a la consola...");
            this.$router.push('/loged');
        }
    },
    mounted() {
        console.log("Componente DiskPage montado. Obteniendo discos...");
        this.fetchDisks();
    }
}
</script>
```
![5](./img/5.png)

  - **Vista partitions:** Muestra todas las particiones dentro de un disco y permite ingresar al contenido dentro de estas.
```vue
<script>
export default {
    name: 'PartitionPage',
    props: ['diskPathEncoded'],
    data() {
        return {
            partitions: [], // { name, type, size, start, fit, status, mountId }
            isLoading: false,
            errorMessage: '',
            decodedDiskPath: ''
        };
    },
    methods: {
        async fetchPartitions() {
            if (!this.diskPathEncoded) { /* ... */ return; }
            try { this.decodedDiskPath = decodeURIComponent(this.diskPathEncoded); } catch (e) { /* ... */ return; }

            this.isLoading = true;
            this.errorMessage = '';
            this.partitions = [];
            const commandString = `partitions -path="${this.decodedDiskPath}"`;
            console.log(`Enviando comando: ${commandString}`);

            try {
                const response = await fetch('http://localhost:3001/', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ command: commandString }) });
                const data = await response.json();
                if (!response.ok || data.error) {  throw new Error(`Error obteniendo particiones: ${data.error || data.output || 'Error desconocido'}`); }
                console.log("Respuesta Partitions:", data.output);
                this.parseAndSetPartitions(data.output);

            } catch (error) {  this.errorMessage = error.message; }
            finally { this.isLoading = false; }
        },

        // Parsea
        parseAndSetPartitions(outputString) {
            if (!outputString || !outputString.startsWith("PARTITIONS:\n")) { this.errorMessage = "Formato inv√°lido"; return; }
            let dataString = outputString.slice("PARTITIONS:\n".length);
            if (dataString.trim() === "") { this.partitions = []; return; }

            const partitionEntries = dataString.split(';');
            const parsedPartitions = [];

            for (const entry of partitionEntries) {
                const trimmedEntry = entry.trim();
                if (trimmedEntry === "") continue;
                const fields = trimmedEntry.split(',');
                if (fields.length < 7) { // Esperamos al menos 7 ahora
                    console.warn("Entrada partici√≥n formato incorrecto (< 7 campos):", entry);
                    continue;
                }

                const partName = fields[0].trim();
                const partType = fields[1].trim();
                const partSizeStr = fields[2].trim();
                const partStartStr = fields[3].trim();
                const partFit = fields[4].trim();
                const partStatus = fields[5].trim();
                const mountId = fields[6].trim(); 

                const partSize = parseInt(partSizeStr, 10);
                const partStart = parseInt(partStartStr, 10);
                if (isNaN(partSize) || isNaN(partStart)) { console.warn(`Datos inv√°lidos p '${partName}'`); continue; }

                parsedPartitions.push({
                    name: partName, type: partType, size: partSize, start: partStart,
                    fit: partFit, status: partStatus,
                    mountId: mountId || null
                });
            }
            this.partitions = parsedPartitions;
            console.log("Particiones parseadas:", this.partitions);
        },

        selectPartition(part) {
            console.log("Partici√≥n seleccionada:", part);
            if (!part.mountId) {
                alert(`La partici√≥n '${part.name}' no est√° montada.`);
                return; // No hacer nada si no est√° montada
            }

            console.log(`Navegando al explorador para partici√≥n ID: ${part.mountId}, ruta inicial: /`);
            try {
                // Codificar la ruta ra√≠z '/' para la URL
                const encodedRootPath = encodeURIComponent('/');
                this.$router.push({
                    name: 'FilesPage', // Aseg√∫rate que este sea el 'name' de tu ruta en router/index.js
                    params: {
                        mountId: part.mountId, 
                        internalPathEncoded: encodedRootPath 
                    }
                });
            } catch (e) {
                console.error("Error al navegar al explorador:", e);
                this.errorMessage = "No se pudo abrir el explorador de archivos.";
            }
        },

        goBack() {
            console.log("Volviendo a la p√°gina de discos...");
            this.$router.push('/disk');
        }
    },
    mounted() {
        console.log("Componente PartitionPage montado.");
        this.fetchPartitions();
    }
}
</script>

```
![6](./img/6.png)


  - **Vista Files:** Se presenta como un explorador de archivo dentro del disco seleccionado.
```vue
<script>

export default {
    name: 'FilesPage',
    props: ['mountId', 'internalPathEncoded'],
    data() {
        return {
            items: [],
            isLoading: false,
            errorMessage: '',
        };
    },
    computed: {
        sortedItems() {
            return [...this.items].sort((a, b) => {
                if (a.name === '.') return -1; if (b.name === '.') return 1;
                if (a.name === '..') return -1; if (b.name === '..') return 1;
                if (a.type !== b.type) { return a.type < b.type ? -1 : 1; }
                return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
            });
        },

        decodedInternalPath() {
            if (!this.internalPathEncoded) return '/';
            try {
                let decoded = decodeURIComponent(this.internalPathEncoded);
                if (!decoded.startsWith('/')) decoded = '/' + decoded;
                if (decoded !== '/' && decoded.endsWith('/')) decoded = decoded.slice(0, -1);
                return decoded;
            } catch (e) {
                console.error("Error decodificando path:", e);
                return '/';
            }
        }
    },
    watch: {
        // Observar cambios en el par√°metro de la ruta para recargar
        internalPathEncoded(newVal, oldVal) {
            if (newVal !== oldVal) {
                console.log("Watcher: Cambio detectado en internalPathEncoded, recargando contenido...");
                this.fetchDirectoryContent();
            }
        }
    },
    methods: {
        // Carga el contenido del directorio actual
        async fetchDirectoryContent() {
            this.isLoading = true;
            this.errorMessage = '';
            this.items = [];

            const pathToList = this.decodedInternalPath;
            // Construcci√≥n del comando:
            console.log(`Enviando comando 'content -id=${this.mountId} -ruta="${pathToList}"'`);
            const commandString = `content -id=${this.mountId} -ruta="${pathToList}"`;

            try {
                // Env√≠o del comando al backend
                const response = await fetch('http://localhost:3001/', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ command: commandString }) });
                const data = await response.json();

                // Manejo de respuesta (asumiendo que el backend devuelve "nombre,tipo\n...")
                if (!response.ok || data.error) {
                    // ... manejo de error ...
                    const errorMsg = data.error || data.output || `Error HTTP ${response.status}`;
                    // Manejar caso espec√≠fico de directorio vac√≠o como no-error
                    if (typeof data.output === 'string' && data.output.includes("Directorio") && data.output.includes("est√° vac√≠o")) {
                        this.errorMessage = ''; this.items = []; console.log(`Directorio '${pathToList}' est√° vac√≠o.`);
                    } else { throw new Error(`Error obteniendo contenido: ${errorMsg}`); }
                } else {
                    this.parseAndSetItems(data.output); // Parsea la respuesta
                }

            } catch (error) { /* ... */ this.errorMessage = error.message; }
            finally { this.isLoading = false; }
        },

        parseAndSetItems(outputString) {
            if (!outputString || typeof outputString !== 'string') { return; }
            const prefix = "CONTENT:\n";
            if (!outputString.startsWith(prefix)) { return; }
            let dataString = outputString.slice(prefix.length);
            if (dataString.trim() === "" || dataString.includes("est√° vac√≠o")) { this.items = []; return; }

            const lines = dataString.split('\n');
            const parsedItems = [];

            for (const line of lines) {
                const trimmedLine = line.trim();
                if (trimmedLine === "") continue;
                const fields = trimmedLine.split(',');

                if (fields.length !== 5) {
                    console.warn("Entrada formato incorrecto (campos != 5):", line);
                    continue;
                }
                const itemName = fields[0].trim();
                const itemType = fields[1].trim();
                const itemMtimeStr = fields[2].trim();
                const itemSizeStr = fields[3].trim();
                const itemPerms = fields[4].trim();

                let itemSize = -1;
                if (itemSizeStr !== "-1") {
                    const parsedSize = parseInt(itemSizeStr, 10);
                    if (!isNaN(parsedSize)) { itemSize = parsedSize; }
                    else { console.warn(`Tama√±o inv√°lido para '${itemName}': ${itemSizeStr}`); }
                }

                if (itemName === '.' || itemName === '..') { continue; }

                parsedItems.push({
                    name: itemName, type: itemType, mtime: itemMtimeStr,
                    size: itemSize, perms: itemPerms
                });
            }
            this.items = parsedItems;
            console.log("Items parseados:", this.items);
        },

        handleItemClick(item) {
            if (item.type === '0') { this.navigateTo(item); } // Directorio
            else if (item.type === '1') { // Archivo
                console.log(`Navegando al visor para archivo: ${item.name}`);
                const currentDecodedPath = this.decodedInternalPath;
                let filePath = (currentDecodedPath === '/') ? '/' + item.name : currentDecodedPath + '/' + item.name;
                try {
                    const encodedFilePath = encodeURIComponent(filePath);
                    this.$router.push({
                        name: 'FileView', // Nombre ruta visor
                        params: { mountId: this.mountId, filePathEncoded: encodedFilePath }
                    });
                } catch (e) { console.error("Error al navegar al visor:", e); this.errorMessage = "Error al abrir archivo."; }
            }
        },

        navigateTo(item) {
            if (item.type !== '0') return;
            const currentDecodedPath = this.decodedInternalPath;
            let newPath = (currentDecodedPath === '/') ? '/' + item.name : currentDecodedPath + '/' + item.name;
            console.log(`Navegando a subdirectorio: ${newPath}`);
            try {
                const newEncodedPath = encodeURIComponent(newPath);
                this.$router.push({
                    name: 'FilesPage', 
                    params: { mountId: this.mountId, internalPathEncoded: newEncodedPath }
                });
            } catch (e) { console.error("Error al navegar a subdirectorio:", e); this.errorMessage = "Error al navegar."; }
        },


        goBackToPartitions() {
            console.log("Volviendo a la selecci√≥n de particiones...");
            this.$router.go(-1); // Ir atr√°s
        },
        formatSize(bytes) {
            if (bytes < 0 || typeof bytes !== 'number' || isNaN(bytes)) return '-';
            if (bytes === 0) return '0 bytes';
            const k = 1024;
            const sizes = ['bytes', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.max(0, Math.floor(Math.log(bytes) / Math.log(k)));
            let num = parseFloat((bytes / Math.pow(k, i)).toFixed(1));
            if (i === 0) { num = Math.round(num); }
            return num + ' ' + sizes[i];
        }


    },
    mounted() {
        console.log("Componente montado.");
        this.fetchDirectoryContent();
    }
}
</script>
```
![7](./img/7.png)

  - **Vista Contenido:** Permite ver le contenido de un archivo seleccionado por en el explorador de archivos.

```vue
<script>
export default {
    name: 'FileView',
    props: ['mountId', 'filePathEncoded'], 
    data() {
        return {
            fileContent: '',
            isLoading: false,
            errorMessage: '',
            decodedFilePath: ''
        };
    },
    computed: {
        decodedFilePathComputed() { 
            if (!this.filePathEncoded) return 'Inv√°lido';
            try { return decodeURIComponent(this.filePathEncoded); }
            catch (e) { console.error("Error decodificando path:", e); return 'Error Path'; }
        }
    },
    methods: {
        async fetchFileContent() {

            if (!this.mountId || !this.filePathEncoded) {
                this.errorMessage = "Error interno: Falta ID de montaje o path del archivo.";
                return;
            }
            this.decodedFilePath = this.decodedFilePathComputed;
            if (this.decodedFilePath === 'Error Path') {
                this.errorMessage = "Error: El path del archivo en la URL es inv√°lido.";
                return;
            }

            this.isLoading = true;
            this.errorMessage = '';
            this.fileContent = '';
            console.log(`Enviando comando 'cat -id=${this.mountId} -path="${this.decodedFilePath}"'`);

            // Construir comando cat
            const commandString = `cat -id=${this.mountId} -path="${this.decodedFilePath}"`;

            try {
                const response = await fetch('http://localhost:3001/', { // URL Backend
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ command: commandString }),
                });
                const data = await response.json();

                if (!response.ok || data.error) {
                    const errorMsg = data.error || data.output || `Error HTTP ${response.status}`;
                    throw new Error(`Error obteniendo contenido del archivo: ${errorMsg}`);
                }

                this.fileContent = data.output; 
                console.log("Contenido del archivo recibido.");

            } catch (error) {
                console.error("Error en fetchFileContent:", error);
                this.errorMessage = error.message || "Error de conexi√≥n o respuesta inv√°lida.";
            } finally {
                this.isLoading = false;
            }
        },

        goBackToFileExplorer() {
            console.log("Volviendo al explorador...");
            this.$router.go(-1);
        }
    },
    mounted() {
        console.log("Componente FileViewerPage montado.");
        this.fetchFileContent();
    }
}
</script>
```
![8](./img/8.png)



El frontend est√° desarrollado con el framework Vue.js y se comunica con el backend mediante una API REST y JSON.


#### Backend
- Tecnolog√≠a: Desarrollado en Go, utilizando el framework web Fiber para la gesti√≥n de rutas y peticiones HTTP de alto rendimiento.
- N√∫cleo: Contiene toda la l√≥gica de simulaci√≥n del sistema de archivos EXT2.
  - API REST: Expone un endpoint (ej. http://localhost:3001/) que acepta peticiones POST con el comando a ejecutar.
  - Analizador (analyzer): Recibe la l√≠nea de comando, la limpia (ignora comentarios, vac√≠os), identifica el comando principal y lo dirige al parser correspondiente.
  - Parsers (commands/Parse...): Funciones espec√≠ficas para cada comando (ParseMkdisk, ParseFdisk, etc.) que validan y extraen los par√°metros usando expresiones regulares y l√≥gica de validaci√≥n. Retornan una estructura espec√≠fica del comando o un error.
  - L√≥gica de Comandos (commands/command...): Funciones que toman la estructura parseada y ejecutan la acci√≥n principal, interactuando con las estructuras del sistema de archivos.
  - Estructuras (structures): Define las estructuras de datos Go (MBR, Partition, EBR, SuperBlock, Inode, etc.) y sus m√©todos de serializaci√≥n/deserializaci√≥n. Contiene tambi√©n la l√≥gica de m√°s bajo nivel (ej. FindInodeByPath, ReadFileContent, CreateFolder, FreeInodeBlocks, allocateDataBlocks).
  - Almacenamiento (stores): Maneja el estado global, como las particiones montadas (MountedPartitions) y el estado de autenticaci√≥n (Auth).
  - Utilidades (utils): Funciones de ayuda gen√©ricas (ej. conversi√≥n de tama√±o, manipulaci√≥n de paths).
  - Reportes (reports): L√≥gica para generar los archivos .dot de Graphviz para cada tipo de reporte.
- Disco Virtual: El "disco" se simula como un archivo binario en el sistema de archivos del host (ej. Disco1.mia). Todas las operaciones leen y escriben directamente en este archivo usando offsets calculados y encoding/binary.
- Comunicaci√≥n: Recibe JSON del frontend, procesa el comando, y devuelve una respuesta JSON con la salida (output) o un mensaje de error (error).

```go
package main

import (
	analyzer "backend/analyzer"
	"fmt" // Importa el paquete "fmt" para formatear e imprimir texto
	"strings"

	"github.com/gofiber/fiber/v2"
	"github.com/gofiber/fiber/v2/middleware/cors"
)

//EStructura para representar el comando de solicitud
type CommandRequest struct {
	Command string `json:"command"`
}

//Estructura para representar la respuesta del comando
type CommandResponse struct {
	Output string `json:"output"`
}


func main() {
	app := fiber.New()

	app.Use(cors.New(cors.Config{}))

	app.Post("/", func(c *fiber.Ctx) error {
		var req CommandRequest
		if err := c.BodyParser(&req); err != nil {
			return c.Status(400).JSON(CommandResponse{
				Output: "Error: Petici√≥n inv√°lida",
			})
		}

		commands := strings.Split(req.Command, "\n")
		output := ""

		for _, cmd := range commands {
			if strings.TrimSpace(cmd) == "" {
				continue
			}

			result, err := analyzer.Analyzer(cmd)
			if err != nil {
				output += fmt.Sprintf("Error: %s\n", err.Error())
			} else {
				output += fmt.Sprintf("%s\n", result)
			}
		}

		if output == "" {
			output = "No se ejecut√≥ ning√∫n comando"
		}

		return c.JSON(CommandResponse{
			Output: output,
		})
	})

	app.Listen(":3001")
}

```
#### Diagrama de integraci√≥n
![2](./img/2.png)

### Explicaci√≥n de las estructuras de datos
Para la creaci√≥n de este proyecto, se usaron estructuras de vital importancia para los sistemas de archivos entre los cuales est√°n MBR, EBR, inodos y bloques. A continuaci√≥n una peque√±a explicaci√≥n de cada una algunas de estas:



#### Estructura MBR
 Ubicado en el primer sector del disco. La estructura MBR se crea junto a un nuevo disco, que en este proyecto es el archivo de la extensi√≥n .mia.
Este contiene dentro de s√≠ la informaci√≥n de todas las particiones del sistema de archivos, por lo que se encuentra en el primer sector del disco. Este contiene la siguiente informaci√≥n:
- Tama√±o del disco en byte
- Fecha de creaci√≥n del disco
- Un n√∫mero √∫nico que lo identifica
- Un ajuste del tipo de partici√≥n
- Informaci√≥n de las cuatro particiones capaces de contener en s√≠

```go
type MBR struct {
	Mbr_size           int32        // Tama√±o del MBR en bytes
	Mbr_creation_date  float32      // Fecha y hora de creaci√≥n del MBR
	Mbr_disk_signature int32        // Firma del disco
	Mbr_disk_fit       [1]byte      // Tipo de ajuste
	Mbr_partitions     [4]Partition // Particiones del MBR
}
```

#### Estructrura EBR
La estructura EBR se utiliza para manejar particiones l√≥gicas dentro de una partici√≥n extendida. Se encuentra en el primer sector de cada partici√≥n l√≥gica y permite encadenar m√∫ltiples particiones l√≥gicas dentro de una extendida. Contiene la siguiente informaci√≥n:
- Estado de la partici√≥n (activa o inactiva).
- Tipo de sistema de archivos.
- Tama√±o de la partici√≥n en bytes.
- Direcci√≥n del siguiente EBR (si existe otra partici√≥n l√≥gica).
- Direcci√≥n de inicio de la partici√≥n l√≥gica
```go
type EBR struct {
	Part_status  [1]byte  // Estado de la partici√≥n
	Part_fit     [1]byte  // Tipo de ajuste
	Part_start   int32    // Byte de inicio de la partici√≥n
	Part_size    int32    // Tama√±o de la partici√≥n
	Part_next    int32    // Direcci√≥n del siguiente EBR (-1 si no hay otro)
	Part_name    [16]byte // Nombre de la partici√≥n
}
```
#### INODO
Los inodos son estructuras fundamentales en el sistema de archivos EXT2, encargadas de almacenar la informaci√≥n de archivos y carpetas. Cada inodo contiene metadatos sobre un archivo o directorio, pero no almacena directamente su contenido. Un inodo incluye la siguiente informaci√≥n:

- Tipo de archivo (archivo regular, directorio, enlace simb√≥lico, etc.).
- Permisos de acceso (lectura, escritura, ejecuci√≥n).
- UID y GID del propietario y grupo del archivo.
- Tama√±o del archivo en bytes.
- Timestamps (fecha de creaci√≥n, modificaci√≥n y acceso).
- N√∫mero de enlaces (cantidad de referencias al inodo).
- Punteros a bloques de datos, organizados en:
  - 12 punteros directos ‚Üí Apuntan directamente a bloques de datos.
  - 1 puntero indirecto simple ‚Üí Apunta a un bloque que contiene m√°s punteros a datos.
  - 1 puntero indirecto doble ‚Üí Apunta a un bloque que contiene punteros a otros bloques de punteros.
  - 1 puntero indirecto triple ‚Üí Apunta a un bloque que contiene punteros a bloques de punteros dobles.

Los inodos permiten una administraci√≥n eficiente del espacio en disco, separando los metadatos de los datos del archivo.

```go
type Inode struct {
	I_uid   int32
	I_gid   int32
	I_size  int32
	I_atime float32
	I_ctime float32
	I_mtime float32
	I_block [15]int32
	I_type  [1]byte
	I_perm  [3]byte
}
```

#### SUPERBLOCK
El SuperBlock es una estructura clave del sistema de archivos EXT2. Contiene la informaci√≥n principal sobre el sistema de archivos y se encuentra al inicio de cada partici√≥n formateada con EXT2. Contiene la siguiente informaci√≥n:
- Tama√±o total del sistema de archivos.
- N√∫mero total de inodos y bloques.
- Tama√±o de los bloques.
- Cantidad de bloques e inodos libres.
- Direcci√≥n del primer bloque de datos.

```go
type SuperBlock struct {
	S_filesystem_type   int32
	S_inodes_count      int32
	S_blocks_count      int32
	S_free_inodes_count int32
	S_free_blocks_count int32
	S_mtime             float32
	S_umtime            float32
	S_mnt_count         int32
	S_magic             int32
	S_inode_size        int32
	S_block_size        int32
	S_first_ino         int32
	S_first_blo         int32
	S_bm_inode_start    int32
	S_bm_block_start    int32
	S_inode_start       int32
	S_block_start       int32
	// Total: 68 bytes
}
```
Basicamente porporciona informaci√≥n general del sistema de archivos.

#### BITMAP
No son una struct Go, sino √°reas de bytes en el disco.

- Ubicaci√≥n: Indicada por S_bm_inode_start y S_bm_block_start en el SuperBloque.
- Tama√±o: S_inodes_count bytes para el bitmap de inodos, S_blocks_count bytes para el de bloques.
- Formato: Cada byte representa un inodo o bloque. '0' indica libre, '1' indica usado.
- Funci√≥n: Permiten encontrar r√°pidamente inodos/bloques libres y llevar control del espacio.
  
#### POINTERBLOCK
El PointerBlock es una estructura que almacena direcciones de bloques de datos. Se utiliza para gestionar archivos o carpetas grandes que requieren m√°s de un bloque de almacenamiento. Puede contener:
- Punteros directos a bloques de datos.
- Punteros indirectos a otros PointerBlocks (para estructuras m√°s grandes).
```go
type PointerBlock struct {
	P_pointers [16]int32 // 16 * 4 = 64 bytes
	// Total: 64 bytes
}
```
#### PARTITION
La Partition es una divisi√≥n dentro del disco que puede contener un sistema de archivos. Existen tres tipos en este proyecto:
- Primaria: Contiene directamente un sistema de archivos.
- Extendida: Puede contener m√∫ltiples particiones l√≥gicas.
- L√≥gica: Se almacena dentro de una partici√≥n extendida y contiene un sistema de archivos.
Cada partici√≥n contiene la siguiente informaci√≥n:
- Tipo de partici√≥n.
- Tama√±o en bytes.
- Punto de inicio dentro del disco.
- Estado (activa o inactiva).

```go
type Partition struct {
	Part_status      [1]byte  // Estado de la partici√≥n
	Part_type        [1]byte  // Tipo de partici√≥n
	Part_fit         [1]byte  // Ajuste de la partici√≥n
	Part_start       int32    // Byte de inicio de la partici√≥n
	Part_size        int32    // Tama√±o de la partici√≥n
	Part_name        [16]byte // Nombre de la partici√≥n
	Part_correlative int32    // Correlativo de la partici√≥n
	Part_id          [4]byte  // ID de la partici√≥n
}
```

#### FOLDERBLOCK
El FolderBlock almacena la informaci√≥n de una carpeta dentro del sistema de archivos. Contiene una lista de entradas que pueden ser archivos o subcarpetas. Cada entrada almacena:
- Nombre de la carpeta o archivo.
- N√∫mero de inodo asociado.

Si una carpeta tiene muchas entradas, puede utilizar PointerBlocks para almacenar m√°s referencias.

```go
type FolderBlock struct {
	B_content [4]FolderContent // 4 * 16 = 64 bytes
	// Total: 64 bytes
}

type FolderContent struct {
	B_name  [12]byte
	B_inodo int32
	// Total: 16 bytes
}
```

#### FILEBLOCK
El FileBlock almacena datos de un archivo en bloques de tama√±o fijo. Cada FileBlock es parte de la estructura de un archivo y contiene:
- Datos del archivo en formato binario.
- Punteros a otros FileBlocks si el archivo es grande.
```go
type FileBlock struct {
	B_content [64]byte
}
```

#### JOURNAL
El Journal es la caracter√≠stica central que diferencia a EXT3 de EXT2.Es un √°rea dedicada que funciona como un registro transaccional. Su proposito es registrar las transacciones que se van a realizar en los metadatos del sistema de archivos antes de que se escriban en sus ubicaciones finales. Contiene:
- Marcadores de inicio y fin de transacci√≥n.
- Identificadores de los bloques de metadatos que se modificar√°n.
- Copias de c√≥mo deben quedar esos bloques de metadatos despu√©s del cambio.
```go
type Journal struct {
	J_count   int32       // 4 bytes
	J_content Information // 110 bytes
	// Total: 114 bytes
}

type Information struct {
	I_operation [10]byte // 10 bytes
	I_path      [32]byte // 32 bytes
	I_content   [64]byte // 64 bytes
	I_date      float32  // 4 bytes
	// Total: 110 bytes
}
```
#### users.txt (Archivo Especial)
- Ubicaci√≥n: /users.txt (Inodo 1, por convenci√≥n de CreateUsersFile).
- Formato: Archivo de texto plano, cada l√≠nea representa un usuario o grupo.
  - L√≠nea Grupo: GID,G,GroupName (Ej: 1,G,root)
  - L√≠nea Usuario: UID,U,GroupName,Username,Password (Ej: 2,U,root,admin,adminpass)
- Prop√≥sito: Almacena la informaci√≥n de usuarios y grupos para los comandos de gesti√≥n (mkusr, rmusr, mkgrp, rmgrp, chgrp) y autenticaci√≥n (login). UID y GID comparten el mismo espacio num√©rico (el ID m√°s alto + 1 se usa para el siguiente usuario o grupo).

### Descripci√≥n de los comandos implementados
Los comando utilizado para la ejecuci√≥n de todo el proceso fueron los siguiente:

#### MKDISK
Este comando se utiliza para crear un archivo binario que simula un disco duro f√≠sico.  Al crearlo, se especifica el tama√±o, la unidad de medida (KB, MB), el tipo de ajuste para las particiones (Best Fit, First Fit, Worst Fit) y la ruta donde se guardar√° el archivo.  El archivo binario se inicializa llen√°ndolo con ceros binarios, representando el espacio disponible del disco. 
```go
func commandMkdisk(mkdisk *MKDISK) error {
	// Convertir el tama√±o a bytes
	sizeBytes, err := utils.ConvertToBytes(mkdisk.size, mkdisk.unit)
	if err != nil {
		fmt.Println("Error converting size:", err)
		return err
	}

	// Crear el disco con el tama√±o proporcionado
	err = createDisk(mkdisk, sizeBytes)
	if err != nil {
		fmt.Println("Error creating disk:", err)
		return err
	}

	// Crear el MBR con el tama√±o proporcionado
	err = createMBR(mkdisk, sizeBytes)
	if err != nil {
		fmt.Println("Error creating MBR:", err)
		return err
	}

	return nil
}
```

#### FDISK
Este comando es fundamental para la administraci√≥n de particiones dentro de un disco duro virtual.  Permite crear, eliminar o modificar particiones.  Al crear una partici√≥n, se pueden especificar par√°metros como el tama√±o, la unidad de medida, la ruta del disco, el tipo de partici√≥n (primaria, extendida o l√≥gica), el algoritmo de ajuste de espacio (Best Fit, First Fit, Worst Fit) y el nombre de la partici√≥n.  El sistema debe controlar que se cumplan las reglas de las particiones (m√°ximo 4 particiones primarias o extendidas, solo una extendida por disco, etc.) y mostrar mensajes de error si no se pueden realizar las operaciones.
```go
func commandFdisk(cmd *FDISK, operation string) (string, error) {

	switch operation {
	case "create":
		fmt.Println("Ejecutando operaci√≥n: CREAR")
		// Convertir tama√±o a bytes para creaci√≥n
		sizeBytes, err := utils.ConvertToBytes(cmd.size, cmd.unit)
		if err != nil {
			return "", fmt.Errorf("error convirtiendo -size a bytes: %w", err)
		}

		// Validar tama√±o contra disco
		fileInfo, errStat := os.Stat(cmd.path)
		if errStat != nil {
			return "", fmt.Errorf("error accediendo al disco '%s': %w", cmd.path, errStat)
		}
		if int64(sizeBytes) > fileInfo.Size() {
			return "", fmt.Errorf("tama√±o de partici√≥n solicitado (%d bytes) excede tama√±o del disco (%d bytes)", sizeBytes, fileInfo.Size())
		}
		if sizeBytes <= 0 {
			return "", fmt.Errorf("tama√±o calculado de partici√≥n debe ser positivo (%d bytes)", sizeBytes)
		}

		// Llamar a la funci√≥n de creaci√≥n apropiada seg√∫n cmd.typ
		switch cmd.typ {
		case "P":
			err = createPrimaryPartition(cmd, sizeBytes)
		case "E":
			err = createExtendedPartition(cmd, sizeBytes)
		case "L":
			err = createLogicalPartition(cmd, sizeBytes)
		default:
			err = fmt.Errorf("tipo de partici√≥n desconocido '%s' para creaci√≥n", cmd.typ)
		}
		if err != nil {
			return "", err
		} 

		// Mensaje de √©xito para CREAR
		return fmt.Sprintf("FDISK: Partici√≥n '%s' creada exitosamente\n"+
			"-> Path: %s\n"+
			"-> Tama√±o: %d%s\n"+
			"-> Tipo: %s\n"+
			"-> Fit: %s",
			cmd.name, cmd.path, cmd.size, cmd.unit, cmd.typ, cmd.fit), nil

	case "delete":
		fmt.Println("Ejecutando operaci√≥n: DELETE")
		err := deletePartition(cmd) // Llamar a la nueva funci√≥n de borrado
		if err != nil {
			return "", err
		} 
		// Mensaje de √©xito para DELETE
		return fmt.Sprintf("FDISK: Partici√≥n '%s' eliminada exitosamente (modo: %s)\n"+
			"-> Path: %s",
			cmd.name, cmd.delete, cmd.path), nil

	case "add":
		fmt.Println("Ejecutando operaci√≥n: ADD")
		err := addSpaceToPartition(cmd) 
		if err != nil {
			return "", err
		} 
		addDesc := "a√±adido"
		absAdd := cmd.add
		if cmd.add < 0 {
			addDesc = "quitado"
			absAdd = -absAdd
		}
		return fmt.Sprintf("FDISK: Espacio %s exitosamente a la partici√≥n '%s'\n"+
			"-> Path: %s\n"+
			"-> Cantidad: %d%s",
			addDesc, cmd.name, cmd.path, absAdd, cmd.unit), nil

	default:
		return "", fmt.Errorf("operaci√≥n fdisk desconocida: %s", operation)
	}
}
```

#### MOUNT
Permite "montar" una partici√≥n de un disco en el sistema.  Esto implica hacerla accesible para las operaciones del sistema de archivos.  El comando recibe como par√°metros la ruta del disco y el nombre de la partici√≥n a montar.  Al montar, se le asigna un ID a la partici√≥n y se actualiza su estado en las estructuras de datos.  Es importante tener en cuenta que el montaje se realiza en la memoria RAM, no en el disco.
```go
func commandMount(mount *MOUNT) error {
	// Crear una instancia de MBR
	var mbr structures.MBR

	// Deserializar la estructura MBR desde un archivo binario
	err := mbr.Deserialize(mount.path)
	if err != nil {
		fmt.Println("Error deserializando el MBR:", err)
		return err
	}

	// Buscar la partici√≥n con el nombre especificado
	partition, indexPartition := mbr.GetPartitionByName(mount.name)
	if partition == nil {
		fmt.Println("Error: la partici√≥n no existe")
		return errors.New("la partici√≥n no existe")
	}

	/* SOLO PARA VERIFICACI√ìN */
	// Print para verificar que la partici√≥n se encontr√≥ correctamente
	fmt.Println("\nPartici√≥n disponible:")
	partition.PrintPartition()

	//Aqu√≠ verifico si no se mont√≥ antes
	for _, valor:= range stores.ListPatitions{
		if valor == mount.name{
			fmt.Println("Error: la partici√≥n ya est√° montada")
			return errors.New("la partici√≥n ya est√° montada")
		}
	}

	// Generar un id √∫nico para la partici√≥n
	idPartition, partitionCorrelative, err := generatePartitionID(mount)
	if err != nil {
		fmt.Println("Error generando el id de partici√≥n:", err)
		return err
	}



	//  Guardar la partici√≥n montada en la lista de montajes globales
	stores.MountedPartitions[idPartition] = mount.path
	stores.ListPatitions = append(stores.ListPatitions, mount.name)
	stores.ListMounted = append(stores.ListMounted, idPartition)

	// Modificamos la partici√≥n para indicar que est√° montada
	partition.MountPartition(partitionCorrelative, idPartition)

	/* SOLO PARA VERIFICACI√ìN */
	// Print para verificar que la partici√≥n se haya montado correctamente
	fmt.Println("\nPartici√≥n montada (modificada):")
	partition.PrintPartition()

	// Guardar la partici√≥n modificada en el MBR
	mbr.Mbr_partitions[indexPartition] = *partition

	// Serializar la estructura MBR en el archivo binario
	err = mbr.Serialize(mount.path)
	if err != nil {
		fmt.Println("Error serializando el MBR:", err)
		return err
	}

	return nil
}
```
#### UNMOUNT
Permite "desmontar" una partici√≥n de un disco en el sistema.  Esto implica hacerla inaccesible para las operaciones del sistema de archivos.  El comando recibe como par√°metros la ruta del disco y el nombre de la partici√≥n a desmontar.  Al desmontar, se desasigna su estado en las estructuras de datos, eliminandolo de la memoria RAM.
```go
func commandUnmount(cmd UNMOUNT) error {
	fmt.Printf("Intentando desmontar partici√≥n con ID: %s\n", cmd.id)

	// 1. Verificar si el ID est√° realmente montado en nuestro store
	diskPath, mounted := stores.MountedPartitions[cmd.id]
	if !mounted {
		return fmt.Errorf("error: la partici√≥n con id '%s' no se encuentra montada", cmd.id)
	}
	fmt.Printf("  Partici√≥n encontrada en disco: %s\n", diskPath)

	// Obtener el MBR y el puntero a la Partici√≥n en memoria
	mbr, partitionPtr, _, err := stores.GetMountedPartitionInfo(cmd.id)
	if err != nil {
		return fmt.Errorf("error cr√≠tico al obtener informaci√≥n de la partici√≥n '%s' desde el disco '%s': %w", cmd.id, diskPath, err)
	}

	partitionName := strings.TrimRight(string(partitionPtr.Part_name[:]), "\x00 ")

	// Modificar el estado de la partici√≥n en memoria 
	fmt.Printf("  Modificando estado de montaje para partici√≥n '%s' (ID: %s) en MBR...\n", partitionName, cmd.id)
	partitionPtr.Part_correlative = 0
	partitionPtr.Part_id = [4]byte{}  // Limpiar ID
	partitionPtr.Part_status[0] = '0' 
	fmt.Println("  Estado en memoria MBR modificado:")
	partitionPtr.PrintPartition()

	// Serializar el MBR modificado de vuelta al disco
	fmt.Println("  Serializando MBR actualizado al disco...")
	err = mbr.Serialize(diskPath)
	if err != nil {
		fmt.Printf("¬°ERROR CR√çTICO! No se pudo guardar el MBR actualizado en '%s': %v\n", diskPath, err)
		fmt.Println("El estado de montaje en disco puede no haberse actualizado.")
		return fmt.Errorf("error fatal al guardar MBR actualizado para desmontaje: %w", err)
	}
	fmt.Println("  MBR guardado exitosamente.")

	// Eliminar la partici√≥n de los stores globales
	fmt.Printf("  Eliminando partici√≥n ID '%s' de stores globales...\n", cmd.id)
	delete(stores.MountedPartitions, cmd.id) // Quitar del mapa principal

	// Quitar ID de ListMounted
	foundIndex := -1
	for i, mountedID := range stores.ListMounted {
		if mountedID == cmd.id {
			foundIndex = i
			break
		}
	}
	if foundIndex != -1 {
		stores.ListMounted = slices.Delete(stores.ListMounted, foundIndex, foundIndex+1) // Go 1.21+
	} else {
		fmt.Printf("Advertencia: ID '%s' no encontrado en stores.ListMounted para eliminar.\n", cmd.id)
	}

	foundNameIndex := -1
	if partitionName != "" { // Solo intentar si obtuvimos un nombre
		for i, name := range stores.ListPatitions {
			if name == partitionName {
				foundNameIndex = i
				break
			}
		}
		if foundNameIndex != -1 {
			stores.ListPatitions = slices.Delete(stores.ListPatitions, foundNameIndex, foundNameIndex+1) // Go 1.21+
			fmt.Printf("  Nombre '%s' eliminado de stores.ListPatitions.\n", partitionName)
		} else {
			fmt.Printf("Advertencia: Nombre '%s' no encontrado en stores.ListPatitions para eliminar.\n", partitionName)
		}
	}

	fmt.Printf("  Stores actualizados. Montadas ahora: %v\n", stores.ListMounted)

	//Logout si era la partici√≥n activa
	if stores.Auth.IsAuthenticated() && stores.Auth.GetPartitionID() == cmd.id {
		fmt.Println("INFO: Se est√° desmontando la partici√≥n activa. Realizando logout autom√°tico.")
		stores.Auth.Logout()
	}

	fmt.Println("Desmontaje completado.")
	return nil
}
```


#### MKFS
Este comando formatea una partici√≥n, prepar√°ndola para almacenar archivos y directorios.  En este caso, el formateo se realiza con el sistema de archivos EXT2 o EXT3.  Adem√°s, crea un archivo llamado "users.txt" en el directorio ra√≠z de la partici√≥n, el cual almacenar√° informaci√≥n sobre los usuarios y grupos del sistema.  Los par√°metros que recibe son el ID de la partici√≥n a formatear y, opcionalmente, el tipo de formateo (completo). 
```go
func commandMkfs(mkfs *MKFS) error {
	fmt.Printf("Iniciando formateo MKFS para partici√≥n ID: %s, Tipo: %s, Sistema de Archivos: %s\n", mkfs.id, mkfs.typ, mkfs.fs)

	// Obtener Info de la Partici√≥n
	_, mountedPartitionInfo, partitionPath, err := stores.GetMountedPartitionInfo(mkfs.id) // Usar la funci√≥n corregida
	if err != nil {
		return fmt.Errorf("error obteniendo informaci√≥n de la partici√≥n '%s': %w", mkfs.id, err)
	}
	fmt.Println("\nInformaci√≥n de la Partici√≥n:")
	mountedPartitionInfo.PrintPartition()
	if mountedPartitionInfo.Part_size <= int32(binary.Size(structures.SuperBlock{}))+1024 {
		return fmt.Errorf("la partici√≥n '%s' es demasiado peque√±a para formatear", mkfs.id)
	}

	// Calcular n
	n := calculateN(mountedPartitionInfo)
	fmt.Println("\nValor de n calculado:", n)
	minInodes := int32(3)
	if mkfs.fs == "2fs" {
		minInodes = 2
	}
	if n < minInodes {
		return fmt.Errorf("espacio insuficiente para estructuras b√°sicas (n=%d, min=%d)", n, minInodes)
	}

	// Crear SuperBloque Inicial
	superBlock := createSuperBlock(mountedPartitionInfo, n, mkfs.fs)
	if superBlock == nil {
		return errors.New("fall√≥ la creaci√≥n del superbloque inicial")
	}
	fmt.Println("\nSuperBloque Inicial Creado:")
	superBlock.Print()

	// Crear Bitmaps Vac√≠os
	fmt.Println("Creando bitmaps iniciales...")
	err = superBlock.CreateBitMaps(partitionPath)
	if err != nil {
		return fmt.Errorf("error al crear bitmaps: %w", err)
	}

	// Crear Estructuras Iniciales
	fmt.Println("Creando estructuras iniciales del sistema de archivos...")
	err = createInitialStructures(superBlock, partitionPath, mkfs.fs)
	if err != nil {
		return fmt.Errorf("error al crear estructuras iniciales: %w", err)
	}
	fmt.Println("Estructuras iniciales creadas.")

	// Establecer Punteros a Primer Libre en SuperBloque
	fmt.Println("Buscando primer inodo y bloque libres...")
	nextFreeInodeIdx, errInode := superBlock.FindFreeInode(partitionPath)
	if errInode != nil {
		fmt.Printf("Advertencia: No se encontr√≥ inodo libre post-inicializaci√≥n: %v. S_first_ino=-1.\n", errInode)
		superBlock.S_first_ino = -1
	} else {
		superBlock.S_first_ino = nextFreeInodeIdx
		fmt.Printf("  Primer inodo libre encontrado: %d\n", nextFreeInodeIdx)
	}

	nextFreeBlockIdx, errBlock := superBlock.FindFreeBlock(partitionPath)
	if errBlock != nil {
		fmt.Printf("Advertencia: No se encontr√≥ bloque libre post-inicializaci√≥n: %v. S_first_blo=-1.\n", errBlock)
		superBlock.S_first_blo = -1
	} else {
		superBlock.S_first_blo = nextFreeBlockIdx
		fmt.Printf("  Primer bloque libre encontrado: %d\n", nextFreeBlockIdx)
	}
	fmt.Printf("Superbloque actualizado con S_first_ino=%d, S_first_blo=%d\n", superBlock.S_first_ino, superBlock.S_first_blo)

	// Imprimir y Serializar SuperBloque Final
	fmt.Println("\nSuperBloque Finalizado (antes de serializar):")
	superBlock.Print()
	fmt.Println("Serializando SuperBloque final...")
	err = superBlock.Serialize(partitionPath, int64(mountedPartitionInfo.Part_start))
	if err != nil {
		return fmt.Errorf("error al serializar el superbloque final: %w", err)
	}

	fmt.Println("Formateo MKFS completado.")
	return nil
}
```

#### REP
Este comando genera reportes sobre el sistema de archivos.  Recibe como par√°metros el nombre del reporte a generar, la ruta donde se guardar√° el reporte y el ID de la partici√≥n a utilizar.  Algunos reportes pueden recibir par√°metros adicionales, como la ruta de un archivo o carpeta.  Los reportes se generan utilizando Graphviz.
```go
func commandRep(rep *REP) error {
	// Obtener la partici√≥n montada
	mountedMbr, mountedSb, mountedDiskPath, err := stores.GetMountedPartitionRep(rep.id)
	if err != nil {
		return err
	}

	// Switch para manejar diferentes tipos de reportes
	switch rep.name {
	case "mbr":
		err = reports.ReportMBR(mountedMbr, mountedDiskPath, rep.path)
		if err != nil {
			fmt.Printf("Error: %v\n", err)
			return err
		}
	case "inode":
		err = reports.ReportInode(mountedSb, mountedDiskPath, rep.path)
		if err != nil {
			fmt.Printf("Error: %v\n", err)
			return err

		}
	case "bm_inode":
		err = reports.ReportBMInode(mountedSb, mountedDiskPath, rep.path)
		if err != nil {
			fmt.Printf("Error: %v\n", err)
			return err

		}
	case "disk":
		err = reports.ReportDisk(mountedMbr, mountedDiskPath, rep.path)
		if err != nil {
			fmt.Printf("Error: %v\n", err)
			return err

		}
	case "bm_block":
		err = reports.ReportBMBlock(mountedSb, mountedDiskPath, rep.path)
		if err != nil {
			fmt.Printf("Error: %v\n", err)
			return err

		}
	case "sb":
		err = reports.ReportSuperBlock(mountedSb, mountedDiskPath, rep.path)
		if err != nil {
			fmt.Printf("Error: %v\n", err)
			return err

		}
	case "block":
		err = reports.ReportBlock(mountedSb, mountedDiskPath, rep.path)
		if err != nil {
			fmt.Printf("Error: %v\n", err)
			return err
		}
	case "tree":
		err = reports.ReportTree(mountedSb, mountedDiskPath, rep.path)
		if err != nil {
			fmt.Printf("Error: %v\n", err)
			return	 err
		}

	case "file":
		err = reports.ReportFile(mountedSb, mountedDiskPath, rep.path, rep.path_file_ls)
		if err != nil {
			fmt.Printf("Error: %v\n", err)
			return err
		}
	case "ls":
		err = reports.ReportLS(mountedSb, mountedDiskPath, rep.path, rep.path_file_ls)
		if err != nil {
			fmt.Printf("Error: %v\n", err)
			return err
		}

	}

	return nil
}
```

#### MKDIR
Crea un nuevo directorio (carpeta).  Es similar a MKFILE, pero para crear carpetas.  Recibe como par√°metros la ruta de la carpeta y, opcionalmente, un indicador para crear las carpetas padre en la ruta.
```go
func commandMkdir(mkdir *MKDIR) error {
	// Obtener la partici√≥n montada
	partitionSuperblock, mountedPartition, partitionPath, err := stores.GetMountedPartitionSuperblock(IdPartition)
	if err != nil {
		return fmt.Errorf("error al obtener la partici√≥n montada: %w", err)
	}

	// Crear el directorio
	err = createDirectory(mkdir.path, partitionSuperblock, partitionPath, mountedPartition)
	if err != nil {
		err = fmt.Errorf("error al crear el directorio: %w", err)
	}

	return err
}
```

#### RMDISK
Su funci√≥n es eliminar un archivo que previamente fue creado para simular un disco duro.  El √∫nico par√°metro necesario es la ruta del archivo que se desea eliminar.  Si el archivo no existe, el sistema debe mostrar un mensaje de error.  
```go
func commandRmdisk(rmdisk *RMDISK) error {

	if _, err := os.Stat(rmdisk.path); os.IsNotExist(err) {
		return fmt.Errorf("no existe el archivo %s", rmdisk.path)
	}

	// Intentar eliminar el archivo
	err := os.Remove(rmdisk.path)
	if err != nil {
		return fmt.Errorf("error al eliminar el archivo %s: %v", rmdisk.path, err)
	}

	fmt.Printf("Disco %s eliminado exitosamente.\n", rmdisk.path)

	return nil
}
```

#### MOUNTED
Este comando muestra un listado de todas las particiones que han sido montadas en la memoria del sistema.  Generalmente, muestra informaci√≥n como el ID de cada partici√≥n montada.  No recibe par√°metros.  
```go
func commandMounted() (string, error){
	if len(stores.ListMounted) == 0 {
		return "", errors.New("no hay particiones montadas")
	}

	var sb strings.Builder
	sb.WriteString("Particiones montadas:\n")
	for _, path := range stores.ListMounted {
		sb.WriteString(path)
		sb.WriteString("\n")
	}
	return sb.String(), nil
}
```

#### CAT
Permite mostrar el contenido de un archivo.  Recibe como par√°metros la ruta del archivo cuyo contenido se quiere mostrar y el id de la partici√≥n en la que se encuentra el archivo.  Si un archivo no existe o el usuario no tiene permisos de lectura, se debe mostrar un mensaje de error.  
```go
func commandCat(cmd *CAT) (string, error) {

	var targetPartitionID string
	var diskPath string
	var partitionSuperblock *structures.SuperBlock
	var err error

	// Determinar partici√≥n
	if cmd.id != "" {
		targetPartitionID = cmd.id
		fmt.Printf("Intentando leer archivo '%s' en partici√≥n especificada '%s'\n", cmd.path, targetPartitionID)
		partitionSuperblock, _, diskPath, err = stores.GetMountedPartitionSuperblock(targetPartitionID)
		if err != nil {
			return "", fmt.Errorf("error obteniendo partici√≥n '%s': %w", targetPartitionID, err)
		}
	} else {
		fmt.Printf("Intentando leer archivo '%s' en partici√≥n activa\n", cmd.path)
		if !stores.Auth.IsAuthenticated() {
			return "", errors.New("cat requiere sesi√≥n si no se especifica -id")
		}
		_, _, targetPartitionID = stores.Auth.GetCurrentUser()
		if targetPartitionID == "" {
			return "", errors.New("no hay partici√≥n activa y no se especific√≥ -id")
		}
		partitionSuperblock, _, diskPath, err = stores.GetMountedPartitionSuperblock(targetPartitionID)
		if err != nil {
			return "", fmt.Errorf("error obteniendo partici√≥n activa '%s': %w", targetPartitionID, err)
		}
	}

	// Validar SB
	if partitionSuperblock.S_magic != 0xEF53 {
		return "", fmt.Errorf("magia inv√°lida en partici√≥n '%s'", targetPartitionID)
	}
	if partitionSuperblock.S_inode_size <= 0 || partitionSuperblock.S_block_size <= 0 {
		return "", fmt.Errorf("tama√±o inodo/bloque inv√°lido en '%s'", targetPartitionID)
	}

	// Encontrar Inodo del Archivo
	fmt.Printf("Buscando inodo para archivo: %s (en disco %s)\n", cmd.path, diskPath)
	_, targetInode, errFind := structures.FindInodeByPath(partitionSuperblock, diskPath, cmd.path)
	if errFind != nil {
		return "", fmt.Errorf("error: no se encontr√≥ el archivo '%s': %w", cmd.path, errFind)
	}

	// Verificar que es un ARCHIVO
	if targetInode.I_type[0] != '1' {
		return "", fmt.Errorf("error: la ruta '%s' no corresponde a un archivo (es tipo %c)", cmd.path, targetInode.I_type[0])
	}

	// Verificar Permiso de Lectura
	currentUser, userGIDStr, _ := stores.Auth.GetCurrentUser()
	if !stores.Auth.IsAuthenticated() && currentUser != "root" {
		return "", errors.New("se requiere sesi√≥n para verificar permisos")
	}
	fmt.Printf("Verificando permiso de lectura para usuario '%s' en '%s'...\n", currentUser, cmd.path)
	if !checkPermissions(currentUser, userGIDStr, 'r', targetInode, partitionSuperblock, diskPath) { // Asume checkPermissions existe
		return "", fmt.Errorf("permiso denegado: usuario '%s' no puede leer '%s'", currentUser, cmd.path)
	}
	fmt.Println("Permiso de lectura concedido.")

	// Leer Contenido del Archivo
	fmt.Printf("Leyendo contenido del archivo (inodo %d)...\n", targetInode.I_uid) // UID no es √≠ndice, pero es info √∫til
	content, errRead := structures.ReadFileContent(partitionSuperblock, diskPath, targetInode)
	if errRead != nil {
		return "", fmt.Errorf("error leyendo contenido de '%s': %w", cmd.path, errRead)
	}

	fmt.Printf("Contenido le√≠do: %d bytes\n", len(content))
	return content, nil 
}

```

#### LOGIN
Se utiliza para iniciar una sesi√≥n en el sistema.  Los par√°metros requeridos son el nombre de usuario, la contrase√±a y el ID de la partici√≥n en la que se desea iniciar sesi√≥n.  El sistema debe verificar que el usuario exista y que la contrase√±a sea correcta.  No se puede iniciar una nueva sesi√≥n sin cerrar la anterior.
```go
func commandLogin(login *LOGIN) error {
	// Verificar si ya hay una sesi√≥n activa
	if stores.Auth.IsAuthenticated() {
		_, _, currentPartition := stores.Auth.GetCurrentUser()
		if currentPartition == login.id {
			return fmt.Errorf("ya hay una sesi√≥n activa en la partici√≥n '%s' para el usuario '%s'", login.id, stores.Auth.Username)
		} else {
			return fmt.Errorf("ya hay una sesi√≥n activa en otra partici√≥n ('%s'). Debes hacer 'logout' primero", currentPartition)
		}
	}

	// Obtener la partici√≥n montada y el superbloque
	partitionSuperblock, _, partitionPath, err := stores.GetMountedPartitionSuperblock(login.id)
	if err != nil {
		_, exists := stores.MountedPartitions[login.id]
		if !exists {
			return fmt.Errorf("la partici√≥n con id '%s' no est√° montada", login.id)
		}
		return fmt.Errorf("error al obtener la partici√≥n montada '%s': %w", login.id, err)
	}
	if partitionSuperblock.S_magic != 0xEF53 {
		return fmt.Errorf("la partici√≥n '%s' no tiene un sistema de archivos EXT2 v√°lido (magic number incorrecto)", login.id)
	}

	// Leer /users.txt
	fmt.Println("Buscando y leyendo /users.txt...")
	_, usersInode, errFind := structures.FindInodeByPath(partitionSuperblock, partitionPath, "/users.txt")
	if errFind != nil {
		return fmt.Errorf("error cr√≠tico: no se pudo encontrar el archivo /users.txt: %w", errFind)
	}
	if usersInode.I_type[0] != '1' {
		return errors.New("error cr√≠tico: /users.txt no es un archivo")
	}

	content, errRead := structures.ReadFileContent(partitionSuperblock, partitionPath, usersInode)
	if errRead != nil {
		return fmt.Errorf("error leyendo el contenido de /users.txt: %w", errRead)
	}
	fmt.Println("Contenido le√≠do de /users.txt.")

	// Verificar si el contenido est√° vac√≠o
	lines := strings.Split(content, "\n")
	foundUser := false
	var storedPassword string

	// Buscar el usuario en las l√≠neas
	for _, line := range lines {
		trimmedLine := strings.TrimSpace(line)
		if trimmedLine == "" {
			continue
		}

		fields := strings.Split(trimmedLine, ",")
		for i := range fields {
			fields[i] = strings.TrimSpace(fields[i])
		}

		if len(fields) == 5 && fields[1] == "U" {
			fileUsername := fields[3]
			filePassword := fields[4]

			if strings.EqualFold(fileUsername, login.user) {
				foundUser = true
				storedPassword = filePassword
				fmt.Printf("Usuario '%s' encontrado.\n", login.user)
				break
			}
		}
	}

	// Verificar si se encontr√≥ el usuario
	if !foundUser {
		return fmt.Errorf("el usuario '%s' no existe en la partici√≥n '%s'", login.user, login.id)
	}

	// Verificar la contrase√±a
	fmt.Println("Verificando contrase√±a...")
	if storedPassword != login.pass { // Comparaci√≥n exacta (case-sensitive) para contrase√±as
		return fmt.Errorf("contrase√±a incorrecta para el usuario '%s'", login.user)
	}

	// Si la validaci√≥n es exitosa, establecer el estado de autenticaci√≥n
	fmt.Println("Login exitoso.")
	stores.Auth.Login(login.user, login.pass, login.id)

	return nil
}
```

#### LOGOUT
Cierra la sesi√≥n activa del usuario.  No recibe par√°metros.  Solo se puede ejecutar si hay una sesi√≥n activa. 
```go
func ParseLogout(tokens []string) (string, error) {
	if len(tokens) != 0 {
		return "", errors.New("el comando logout no acepta par√°metros")
	}
	// Verifica si hay una sesi√≥n activa

	if !stores.Auth.IsAuthenticated() {
		return "", errors.New("no hay ninguna sesi√≥n activa")
	}

	// Cierra la sesi√≥n
	stores.Auth.Logout()
	return "Sesi√≥n terminada", nil
}

```

#### MKGRP
Crea un nuevo grupo de usuarios.  Este comando solo puede ser ejecutado por el usuario "root".  Recibe como par√°metro el nombre del grupo a crear.  El nombre del grupo no puede existir previamente.
```go
// commandMkgrp contiene la l√≥gica principal para crear el grupo
func commandMkgrp(mkgrp *MKGRP) error {
	// Verificar Autenticaci√≥n y Permisos (Root)
	if !stores.Auth.IsAuthenticated() {
		return errors.New("comando mkgrp requiere inicio de sesi√≥n")
	}
	currentUser, _, partitionID := stores.Auth.GetCurrentUser()
	if currentUser != "root" {
		return fmt.Errorf("permiso denegado: solo el usuario 'root' puede ejecutar mkgrp (usuario actual: %s)", currentUser)
	}

	// Obtener Partici√≥n y Superbloque
	partitionSuperblock, mountedPartition, partitionPath, err := stores.GetMountedPartitionSuperblock(partitionID)
	if err != nil {
		return fmt.Errorf("error al obtener la partici√≥n montada '%s': %w", partitionID, err)
	}
	if partitionSuperblock.S_inode_size <= 0 || partitionSuperblock.S_block_size <= 0 {
		return errors.New("tama√±o de inodo o bloque inv√°lido en superbloque")
	}

	// Encontrar y Leer Inodo/Contenido de /users.txt
	fmt.Println("Buscando inodo para /users.txt...")
	usersInodeIndex, usersInode, errFind := structures.FindInodeByPath(partitionSuperblock, partitionPath, "/users.txt")
	if errFind != nil {
		return fmt.Errorf("error cr√≠tico: no se pudo encontrar el archivo /users.txt: %w", errFind)
	}
	if usersInode.I_type[0] != '1' {
		return errors.New("error cr√≠tico: /users.txt no es un archivo")
	}

	fmt.Println("Leyendo contenido actual de /users.txt...")
	oldContent, errRead := structures.ReadFileContent(partitionSuperblock, partitionPath, usersInode)
	if errRead != nil {
		// Si ReadFileContent retorna "" para archivo vac√≠o, esto est√° bien.
		if oldContent != "" { // Solo retornar error si no pudimos leer nada y hubo error
			return fmt.Errorf("error leyendo el contenido de /users.txt: %w", errRead)
		}
		fmt.Println("Advertencia: /users.txt parece vac√≠o o hubo un error menor al leer. Continuando...")
		oldContent = "" // Asegurar que sea un string vac√≠o si hubo error menor o estaba vac√≠o
	}
	// Asegurar que el contenido termine con un salto de l√≠nea para anexar f√°cilmente
	if oldContent != "" && !strings.HasSuffix(oldContent, "\n") {
		oldContent += "\n"
	}

	// Parsear Contenido, Validar Grupo Existente y Obtener Nuevo GID
	fmt.Println("Validando nombre de grupo y buscando GID disponible...")
	lines := strings.Split(oldContent, "\n")
	highestGID := int32(0) // Asumimos que GID 0 no se usa, root es 1

	for _, line := range lines {
		if len(strings.TrimSpace(line)) == 0 {
			continue
		} // Ignorar l√≠neas vac√≠as

		fields := strings.Split(line, ",")
		if len(fields) < 3 {
			continue
		} // L√≠nea mal formada

		// Limpiar espacios
		for i := range fields {
			fields[i] = strings.TrimSpace(fields[i])
		}

		// Verificar si es l√≠nea de grupo y si el nombre ya existe
		if fields[1] == "G" {
			if strings.EqualFold(fields[2], mkgrp.name) {
				return fmt.Errorf("el grupo '%s' ya existe", mkgrp.name)
			}
			// Rastrear GID m√°s alto
			gid64, errConv := strconv.ParseInt(fields[0], 10, 32)
			if errConv == nil {
				gid := int32(gid64)
				if gid > highestGID {
					highestGID = gid
				}
			}
		}
	}
	newGID := highestGID + 1
	fmt.Printf("Nuevo GID asignado: %d\n", newGID)

	// Preparar Nuevo Contenido
	newLine := fmt.Sprintf("%d,G,%s\n", newGID, mkgrp.name)
	newContent := oldContent + newLine
	newSize := int32(len(newContent))

	// Liberar Bloques Antiguos de users.txt
	fmt.Println("Liberando bloques antiguos de /users.txt...")
	errFree := structures.FreeInodeBlocks(usersInode, partitionSuperblock, partitionPath)
	if errFree != nil {
		// Es importante loguear esto pero intentamos continuar si es posible
		fmt.Printf("Error al liberar bloques antiguos de users.txt: %v. Puede haber bloques perdidos.\n", errFree)
	} else {
		fmt.Println("Bloques antiguos liberados.")
	}

	// Asignar Nuevos Bloques para el nuevo contenido
	fmt.Printf("Asignando bloques para nuevo tama√±o (%d bytes)...\n", newSize)
	var newAllocatedBlockIndices [15]int32
	newAllocatedBlockIndices, err = allocateDataBlocks([]byte(newContent), newSize, partitionSuperblock, partitionPath)
	if err != nil {
		return fmt.Errorf("fall√≥ la re-asignaci√≥n de bloques para /users.txt: %w", err)
	}

	// Actualizar Inodo de users.txt
	fmt.Println("Actualizando inodo /users.txt...")
	usersInode.I_size = newSize
	usersInode.I_mtime = float32(time.Now().Unix())
	usersInode.I_atime = usersInode.I_mtime
	usersInode.I_block = newAllocatedBlockIndices // Actualizar con los nuevos bloques

	usersInodeOffset := int64(partitionSuperblock.S_inode_start) + int64(usersInodeIndex)*int64(partitionSuperblock.S_inode_size)
	err = usersInode.Serialize(partitionPath, usersInodeOffset)
	if err != nil {
		return fmt.Errorf("error serializando inodo /users.txt actualizado: %w", err)
	}

	// Serializar Superbloque
	fmt.Println("Serializando SuperBlock despu√©s de MKGRP...")
	err = partitionSuperblock.Serialize(partitionPath, int64(mountedPartition.Part_start))
	if err != nil {
		return fmt.Errorf("error al serializar el superbloque despu√©s de mkgrp: %w", err)
	}

	return nil 
}
```

#### RMGRP
Elimina un grupo de usuarios existente.  Solo puede ser ejecutado por el usuario "root".  Recibe como par√°metro el nombre del grupo a eliminar.  Si el grupo no existe, se debe mostrar un mensaje de error. 
```go
// commandRmgrp contiene la l√≥gica principal para eliminar el grupo
func commandRmgrp(rmgrp *RMGRP) error {
	// Verificar Permisos
	if !stores.Auth.IsAuthenticated() {
		return errors.New("comando rmgrp requiere inicio de sesi√≥n")
	}
	currentUser, _, partitionID := stores.Auth.GetCurrentUser()
	if currentUser != "root" {
		return fmt.Errorf("permiso denegado: solo el usuario 'root' puede ejecutar rmgrp (usuario actual: %s)", currentUser)
	}

	// Obtener Partici√≥n y Superbloque
	partitionSuperblock, mountedPartition, partitionPath, err := stores.GetMountedPartitionSuperblock(partitionID)
	if err != nil {
		return fmt.Errorf("error al obtener la partici√≥n montada '%s': %w", partitionID, err)
	}
	if partitionSuperblock.S_inode_size <= 0 || partitionSuperblock.S_block_size <= 0 {
		return errors.New("tama√±o de inodo o bloque inv√°lido en superbloque")
	}

	// Encontrar y Leer Inodo/Contenido de /users.txt
	fmt.Println("Buscando inodo para /users.txt...")
	usersInodeIndex, usersInode, errFind := structures.FindInodeByPath(partitionSuperblock, partitionPath, "/users.txt")
	if errFind != nil {
		return fmt.Errorf("error cr√≠tico: no se pudo encontrar el archivo /users.txt: %w", errFind)
	}
	if usersInode.I_type[0] != '1' {
		return errors.New("error cr√≠tico: /users.txt no es un archivo")
	}

	fmt.Println("Leyendo contenido actual de /users.txt...")
	oldContent, errRead := structures.ReadFileContent(partitionSuperblock, partitionPath, usersInode)
	// Retorna error si falla la lectura de bloques.
	if errRead != nil {
		return fmt.Errorf("error leyendo el contenido de /users.txt: %w", errRead)
	}

	// Parsear Contenido y Validar Grupo a Eliminar
	fmt.Printf("Buscando grupo '%s' para eliminar...\n", rmgrp.name)
	lines := strings.Split(oldContent, "\n")
	newLines := []string{} // Slice para guardar las l√≠neas que S√ç queremos mantener
	foundGroup := false

	if strings.EqualFold(rmgrp.name, "root") {
		return errors.New("error: el grupo 'root' no puede ser eliminado")
	}

	for _, line := range lines {
		trimmedLine := strings.TrimSpace(line)
		if trimmedLine == "" {
			continue
		}

		fields := strings.Split(trimmedLine, ",")
		for i := range fields {
			fields[i] = strings.TrimSpace(fields[i])
		}

		if len(fields) >= 3 && fields[1] == "G" && strings.EqualFold(fields[2], rmgrp.name) {
			fmt.Printf("Grupo '%s' encontrado (l√≠nea: '%s'). Marcado para eliminaci√≥n.\n", rmgrp.name, line)
			foundGroup = true
		} else {
			newLines = append(newLines, line) 
		}
	}

	// Verificar si se encontr√≥ el grupo
	if !foundGroup {
		return fmt.Errorf("error: el grupo '%s' no fue encontrado", rmgrp.name)
	}


	// Preparar Nuevo Contenido Final
	newContent := strings.Join(newLines, "\n")
	// A√±adir un salto de l√≠nea final
	if newContent != "" && !strings.HasSuffix(newContent, "\n") {
		newContent += "\n"
	}
	newSize := int32(len(newContent))
	fmt.Printf("Nuevo contenido de users.txt preparado (%d bytes).\n", newSize)

	// Liberar Bloques Antiguos de users.txt
	fmt.Println("Liberando bloques antiguos de /users.txt...")
	errFree := structures.FreeInodeBlocks(usersInode, partitionSuperblock, partitionPath)
	if errFree != nil {
		fmt.Printf("ADVERTENCIA: Error al liberar bloques antiguos de users.txt: %v. Puede haber bloques perdidos.\n", errFree)
		return fmt.Errorf("error liberando bloques antiguos: %w", errFree)
	} else {
		fmt.Println("Bloques antiguos liberados.")
	}

	// Asignar Nuevos Bloques para el nuevo contenido
	fmt.Printf("Asignando bloques para nuevo tama√±o (%d bytes)...\n", newSize)
	var newAllocatedBlockIndices [15]int32
	// Usar allocateDataBlocks existente
	newAllocatedBlockIndices, err = allocateDataBlocks([]byte(newContent), newSize, partitionSuperblock, partitionPath)
	if err != nil {
		return fmt.Errorf("fall√≥ la re-asignaci√≥n de bloques para /users.txt: %w", err)
	}

	// Actualizar Inodo de users.txt
	fmt.Println("Actualizando inodo /users.txt...")
	usersInode.I_size = newSize                     // Actualizar tama√±o
	usersInode.I_mtime = float32(time.Now().Unix()) // Actualizar tiempo de modificaci√≥n
	usersInode.I_atime = usersInode.I_mtime         // Actualizar tiempo de acceso
	usersInode.I_block = newAllocatedBlockIndices   // Actualizar lista de bloques

	// Serializar el inodo actualizado
	usersInodeOffset := int64(partitionSuperblock.S_inode_start) + int64(usersInodeIndex)*int64(partitionSuperblock.S_inode_size)
	err = usersInode.Serialize(partitionPath, usersInodeOffset)
	if err != nil {
		return fmt.Errorf("error serializando inodo /users.txt actualizado: %w", err)
	}

	// Serializar Superbloque
	fmt.Println("Serializando SuperBlock despu√©s de RMGRP...")
	err = partitionSuperblock.Serialize(partitionPath, int64(mountedPartition.Part_start))
	if err != nil {
		return fmt.Errorf("error al serializar el superbloque despu√©s de rmgrp: %w", err)
	}

	return nil
}
```

#### MKUSR
Crea un nuevo usuario.  Solo puede ser ejecutado por el usuario "root".  Los par√°metros necesarios son el nombre de usuario, la contrase√±a y el grupo al que pertenecer√° el usuario.  El nombre de usuario no puede existir previamente y el grupo debe existir.  
```go
// commandMkusr contiene la l√≥gica principal para crear el usuario
func commandMkusr(mkusr *MKUSR) error {
	//Verificar Permisos
	if !stores.Auth.IsAuthenticated() {
		return errors.New("comando mkusr requiere inicio de sesi√≥n")
	}
	currentUser, _, partitionID := stores.Auth.GetCurrentUser()
	if currentUser != "root" {
		return fmt.Errorf("permiso denegado: solo el usuario 'root' puede ejecutar mkusr (usuario actual: %s)", currentUser)
	}

	// Obtener Partici√≥n y Superbloque
	partitionSuperblock, mountedPartition, partitionPath, err := stores.GetMountedPartitionSuperblock(partitionID)
	if err != nil {
		return fmt.Errorf("error al obtener la partici√≥n montada '%s': %w", partitionID, err)
	}
	if partitionSuperblock.S_inode_size <= 0 || partitionSuperblock.S_block_size <= 0 {
		return errors.New("tama√±o de inodo o bloque inv√°lido en superbloque")
	}

	// Encontrar y Leer Inodo/Contenido de /users.txt
	fmt.Println("Buscando inodo para /users.txt...")
	usersInodeIndex, usersInode, errFind := structures.FindInodeByPath(partitionSuperblock, partitionPath, "/users.txt")
	if errFind != nil {
		return fmt.Errorf("error cr√≠tico: no se pudo encontrar el archivo /users.txt: %w", errFind)
	}
	if usersInode.I_type[0] != '1' {
		return errors.New("error cr√≠tico: /users.txt no es un archivo")
	}

	fmt.Println("Leyendo contenido actual de /users.txt...")
	oldContent, errRead := structures.ReadFileContent(partitionSuperblock, partitionPath, usersInode)
	if errRead != nil && oldContent == "" {
		return fmt.Errorf("error leyendo el contenido de /users.txt: %w", errRead)
	}
	if oldContent != "" && !strings.HasSuffix(oldContent, "\n") {
		oldContent += "\n"
	}

	// Parsear Contenido
	fmt.Printf("Validando usuario '%s' y grupo '%s'...\n", mkusr.user, mkusr.grp)
	lines := strings.Split(oldContent, "\n")
	highestID := int32(0)
	userExists := false
	groupExists := false

	for _, line := range lines {
		trimmedLine := strings.TrimSpace(line)
		if trimmedLine == "" {
			continue
		}

		fields := strings.Split(trimmedLine, ",")
		for i := range fields {
			fields[i] = strings.TrimSpace(fields[i])
		}

		if len(fields) < 3 {
			continue
		} // Formato m√≠nimo: id,type,name

		// Rastrear ID m√°s alto
		id64, errConv := strconv.ParseInt(fields[0], 10, 32)
		if errConv == nil {
			id := int32(id64)
			if id > highestID {
				highestID = id
			}
		}

		// Verificar si el usuario ya existe
        if len(fields) == 5 && fields[1] == "U" && strings.EqualFold(fields[3], mkusr.user) { // <-- CORRECTO: Usa √≠ndice 3 y verifica longitud 5
            userExists = true
        }

		// Verificar si el grupo existe y obtener su GID
		if fields[1] == "G" && strings.EqualFold(fields[2], mkusr.grp) {
			groupExists = true
		}
	}

	if userExists {
		return fmt.Errorf("error: el usuario '%s' ya existe", mkusr.user)
	}
	if !groupExists {
		return fmt.Errorf("error: el grupo '%s' no existe", mkusr.grp)
	}

	newUID := highestID + 1
	fmt.Printf("Nuevo UID asignado: %d. Pertenecer√° al grupo '%s'.\n", newUID, mkusr.grp)

	// Preparar Nuevo Contenido
	newLine := fmt.Sprintf("%d,U,%s,%s,%s\n", newUID, mkusr.grp, mkusr.user, mkusr.pass) // Usa mkusr.grp (nombre)
	newContent := oldContent + newLine
	newSize := int32(len(newContent))
	fmt.Printf("Nuevo contenido de users.txt preparado (%d bytes).\n", newSize)

	// Liberar Bloques Antiguos de users.txt
	fmt.Println("Liberando bloques antiguos de /users.txt...")
	errFree := structures.FreeInodeBlocks(usersInode, partitionSuperblock, partitionPath)
	if errFree != nil {
		fmt.Printf("ADVERTENCIA: Error al liberar bloques antiguos de users.txt: %v. Puede haber bloques perdidos.\n", errFree)
		return fmt.Errorf("error liberando bloques antiguos: %w", errFree)
	} else {
		fmt.Println("Bloques antiguos liberados.")
	}

	// Asignar Nuevos Bloques para el nuevo contenido
	fmt.Printf("Asignando bloques para nuevo tama√±o (%d bytes)...\n", newSize)
	var newAllocatedBlockIndices [15]int32
	newAllocatedBlockIndices, err = allocateDataBlocks([]byte(newContent), newSize, partitionSuperblock, partitionPath)
	if err != nil {
		return fmt.Errorf("fall√≥ la re-asignaci√≥n de bloques para /users.txt: %w", err)
	}

	// Actualizar Inodo de users.txt
	fmt.Println("Actualizando inodo /users.txt...")
	usersInode.I_size = newSize
	usersInode.I_mtime = float32(time.Now().Unix())
	usersInode.I_atime = usersInode.I_mtime
	usersInode.I_block = newAllocatedBlockIndices

	usersInodeOffset := int64(partitionSuperblock.S_inode_start) + int64(usersInodeIndex)*int64(partitionSuperblock.S_inode_size)
	err = usersInode.Serialize(partitionPath, usersInodeOffset)
	if err != nil {
		return fmt.Errorf("error serializando inodo /users.txt actualizado: %w", err)
	}

	// Serializar Superbloque
	fmt.Println("Serializando SuperBlock despu√©s de MKUSR...")
	err = partitionSuperblock.Serialize(partitionPath, int64(mountedPartition.Part_start))
	if err != nil {
		return fmt.Errorf("error al serializar el superbloque despu√©s de mkusr: %w", err)
	}

	return nil
}
```

#### RMUSR
Elimina un usuario existente.  Solo puede ser ejecutado por el usuario "root".  Recibe como par√°metro el nombre del usuario a eliminar.  Si el usuario no existe, se debe mostrar un mensaje de error.  
```go
func commandRmusr(rmusr *RMUSR) error {
	// Verificar Permisos (Root)
	if !stores.Auth.IsAuthenticated() {
		return errors.New("comando rmusr requiere inicio de sesi√≥n")
	}
	currentUser, _, partitionID := stores.Auth.GetCurrentUser()
	if currentUser != "root" {
		return fmt.Errorf("permiso denegado: solo el usuario 'root' puede ejecutar rmusr (usuario actual: %s)", currentUser)
	}

	// No permitir eliminar el usuario root
	if strings.EqualFold(rmusr.user, "root") {
		return errors.New("error: el usuario 'root' no puede ser eliminado")
	}
	// No permitir eliminar al usuario actualmente logueado
	if strings.EqualFold(rmusr.user, currentUser) && currentUser != "root" {
		return fmt.Errorf("error: no puedes eliminar al usuario '%s' mientras est√° logueado", currentUser)
	}

	// Obtener Partici√≥n y Superbloque
	partitionSuperblock, mountedPartition, partitionPath, err := stores.GetMountedPartitionSuperblock(partitionID)
	if err != nil {
		return fmt.Errorf("error al obtener la partici√≥n montada '%s': %w", partitionID, err)
	}
	if partitionSuperblock.S_inode_size <= 0 || partitionSuperblock.S_block_size <= 0 {
		return errors.New("tama√±o de inodo o bloque inv√°lido en superbloque")
	}

	// Encontrar y Leer Inodo/Contenido de /users.txt
	fmt.Println("Buscando inodo para /users.txt...")
	usersInodeIndex, usersInode, errFind := structures.FindInodeByPath(partitionSuperblock, partitionPath, "/users.txt")
	if errFind != nil {
		return fmt.Errorf("error cr√≠tico: no se pudo encontrar el archivo /users.txt: %w", errFind)
	}
	if usersInode.I_type[0] != '1' {
		return errors.New("error cr√≠tico: /users.txt no es un archivo")
	}

	fmt.Println("Leyendo contenido actual de /users.txt...")
	oldContent, errRead := structures.ReadFileContent(partitionSuperblock, partitionPath, usersInode)
	if errRead != nil {
		return fmt.Errorf("error leyendo el contenido de /users.txt: %w", errRead)
	}

	// Parsear Contenido y Validar Usuario a Eliminar
	fmt.Printf("Buscando usuario '%s' para eliminar...\n", rmusr.user)
	lines := strings.Split(oldContent, "\n")
	newLines := []string{}
	foundUser := false

	for _, line := range lines {
		trimmedLine := strings.TrimSpace(line)
		if trimmedLine == "" {
			continue
		}

		fields := strings.Split(trimmedLine, ",")
		for i := range fields {
			fields[i] = strings.TrimSpace(fields[i])
		}

		if len(fields) >= 4 && fields[1] == "U" && strings.EqualFold(fields[3], rmusr.user) { // <-- Cambiado fields[2] a fields[3]
			fmt.Printf("Usuario '%s' encontrado (l√≠nea: '%s'). Marcado para eliminaci√≥n.\n", rmusr.user, line)
			foundUser = true
		} else {
			// Conservar la l√≠nea original
			newLines = append(newLines, line)
		}
	}
	// Verificar si se encontr√≥ el usuario
	if !foundUser {
		return fmt.Errorf("error: el usuario '%s' no fue encontrado", rmusr.user)
	}

	// Preparar Nuevo Contenido Final
	newContent := strings.Join(newLines, "\n")
	if newContent != "" && !strings.HasSuffix(newContent, "\n") {
		newContent += "\n"
	}
	newSize := int32(len(newContent))
	fmt.Printf("Nuevo contenido de users.txt preparado (%d bytes).\n", newSize)

	// Liberar Bloques Antiguos de users.txt
	fmt.Println("Liberando bloques antiguos de /users.txt...")
	errFree := structures.FreeInodeBlocks(usersInode, partitionSuperblock, partitionPath)
	if errFree != nil {
		fmt.Printf("ADVERTENCIA: Error al liberar bloques antiguos de users.txt: %v. Puede haber bloques perdidos.\n", errFree)
		return fmt.Errorf("error liberando bloques antiguos: %w", errFree)
	} else {
		fmt.Println("Bloques antiguos liberados.")
	}

	// Asignar Nuevos Bloques para el nuevo contenido
	fmt.Printf("Asignando bloques para nuevo tama√±o (%d bytes)...\n", newSize)
	var newAllocatedBlockIndices [15]int32
	newAllocatedBlockIndices, err = allocateDataBlocks([]byte(newContent), newSize, partitionSuperblock, partitionPath)
	if err != nil {
		return fmt.Errorf("fall√≥ la re-asignaci√≥n de bloques para /users.txt: %w", err)
	}

	// Actualizar Inodo de users.txt
	fmt.Println("Actualizando inodo /users.txt...")
	usersInode.I_size = newSize
	usersInode.I_mtime = float32(time.Now().Unix())
	usersInode.I_atime = usersInode.I_mtime
	usersInode.I_block = newAllocatedBlockIndices

	usersInodeOffset := int64(partitionSuperblock.S_inode_start) + int64(usersInodeIndex)*int64(partitionSuperblock.S_inode_size)
	err = usersInode.Serialize(partitionPath, usersInodeOffset)
	if err != nil {
		return fmt.Errorf("error serializando inodo /users.txt actualizado: %w", err)
	}

	// Serializar Superbloque
	fmt.Println("Serializando SuperBlock despu√©s de RMUSR...")
	err = partitionSuperblock.Serialize(partitionPath, int64(mountedPartition.Part_start))
	if err != nil {
		return fmt.Errorf("error al serializar el superbloque despu√©s de rmusr: %w", err)
	}

	return nil // √âxito
}
```

#### CHGRP
Cambia el grupo al que pertenece un usuario.  Solo puede ser ejecutado por el usuario "root".  Los par√°metros son el nombre del usuario y el nombre del nuevo grupo.  El usuario y el grupo deben existir.
```go
func commandChgrp(chgrp *CHGRP) error {
	// Verificar Permisos 
	if !stores.Auth.IsAuthenticated() {
		return errors.New("comando chgrp requiere inicio de sesi√≥n")
	}
	currentUser, _, partitionID := stores.Auth.GetCurrentUser()
	if currentUser != "root" {
		return fmt.Errorf("permiso denegado: solo 'root' puede ejecutar chgrp (actual: %s)", currentUser)
	}

	// Obtener Partici√≥n y Superbloque
	partitionSuperblock, mountedPartition, partitionPath, err := stores.GetMountedPartitionSuperblock(partitionID)
	if err != nil {
		return fmt.Errorf("error al obtener partici√≥n montada '%s': %w", partitionID, err)
	}
	if partitionSuperblock.S_inode_size <= 0 || partitionSuperblock.S_block_size <= 0 {
		return errors.New("tama√±o inv√°lido de inodo/bloque en superbloque")
	}

	//Encontrar y Leer /users.txt
	fmt.Println("Buscando inodo para /users.txt...")
	usersInodeIndex, usersInode, errFind := structures.FindInodeByPath(partitionSuperblock, partitionPath, "/users.txt")
	if errFind != nil {
		return fmt.Errorf("error cr√≠tico: no se pudo encontrar /users.txt: %w", errFind)
	}
	if usersInode.I_type[0] != '1' {
		return errors.New("error cr√≠tico: /users.txt no es un archivo")
	}

	fmt.Println("Leyendo contenido actual de /users.txt...")
	oldContent, errRead := structures.ReadFileContent(partitionSuperblock, partitionPath, usersInode)
	if errRead != nil && oldContent == "" {
		return fmt.Errorf("error leyendo /users.txt: %w", errRead)
	}
	if oldContent != "" && !strings.HasSuffix(oldContent, "\n") {
		oldContent += "\n"
	}

	// Parsear Contenido y Validaciones
	fmt.Printf("Validando usuario '%s' y nuevo grupo '%s'...\n", chgrp.user, chgrp.grp)
	lines := strings.Split(oldContent, "\n")
	newLines := make([]string, 0, len(lines)) // Slice para reconstruir el archivo
	userFound := false
	groupFound := false
	userLineModified := false // bandera para saber si modificamos la l√≠nea del usuario

	// Validar que el nuevo grupo exista
	for _, line := range lines {
		trimmedLine := strings.TrimSpace(line)
		if trimmedLine == "" {
			continue
		}
		fields := strings.Split(trimmedLine, ",")
		for i := range fields {
			fields[i] = strings.TrimSpace(fields[i])
		}
		if len(fields) == 3 && fields[1] == "G" && strings.EqualFold(fields[2], chgrp.grp) {
			groupFound = true
			break
		}
	}
	if !groupFound {
		return fmt.Errorf("error: el nuevo grupo '%s' no existe", chgrp.grp)
	}
	fmt.Printf("Grupo '%s' encontrado y v√°lido.\n", chgrp.grp)

	// Encontrar usuario y reconstruir archivo
	for _, line := range lines {
		trimmedLine := strings.TrimSpace(line)
		if trimmedLine == "" {
			continue
		}

		fields := strings.Split(trimmedLine, ",")
		for i := range fields {
			fields[i] = strings.TrimSpace(fields[i])
		}

		// Verificar si es la l√≠nea del usuario a modificar
		if len(fields) == 5 && fields[1] == "U" && strings.EqualFold(fields[3], chgrp.user) {
			userFound = true
			// Modificar la l√≠nea cambiando el nombre del grupo
			modifiedLine := fmt.Sprintf("%s,U,%s,%s,%s", fields[0], chgrp.grp, fields[3], fields[4])
			newLines = append(newLines, modifiedLine)
			userLineModified = true
			fmt.Printf("L√≠nea del usuario '%s' modificada a: %s\n", chgrp.user, modifiedLine)
		} else {
			// Conservar la l√≠nea original
			newLines = append(newLines, line)
		}
	}

	// Valida si se encontr√≥ al usuario
	if !userFound {
		return fmt.Errorf("error: el usuario '%s' no fue encontrado", chgrp.user)
	}
	if !userLineModified {
		return errors.New("error interno: se encontr√≥ el usuario pero no se modific√≥ la l√≠nea")
	}

	// Preparar Nuevo Contenido Final
	newContent := strings.Join(newLines, "\n")
	if newContent != "" && !strings.HasSuffix(newContent, "\n") {
		newContent += "\n"
	}
	newSize := int32(len(newContent))
	fmt.Printf("Nuevo contenido de users.txt preparado (%d bytes).\n", newSize)

	// Libera Bloques Antiguos de users.txt
	fmt.Println("Liberando bloques antiguos de /users.txt...")
	errFree := structures.FreeInodeBlocks(usersInode, partitionSuperblock, partitionPath)
	if errFree != nil {
		fmt.Printf("ADVERTENCIA: Error al liberar bloques: %v\n", errFree)
	} else {
		fmt.Println("Bloques antiguos liberados.")
	}

	// Asignar Nuevos Bloques para el nuevo contenido
	fmt.Printf("Asignando bloques para nuevo tama√±o (%d bytes)...\n", newSize)
	var newAllocatedBlockIndices [15]int32
	newAllocatedBlockIndices, err = allocateDataBlocks([]byte(newContent), newSize, partitionSuperblock, partitionPath)
	if err != nil {
		return fmt.Errorf("fall√≥ la re-asignaci√≥n de bloques para /users.txt: %w", err)
	}

	// Actualizar Inodo de users.txt
	fmt.Println("Actualizando inodo /users.txt...")
	usersInode.I_size = newSize
	usersInode.I_mtime = float32(time.Now().Unix())
	usersInode.I_atime = usersInode.I_mtime
	usersInode.I_block = newAllocatedBlockIndices

	usersInodeOffset := int64(partitionSuperblock.S_inode_start) + int64(usersInodeIndex)*int64(partitionSuperblock.S_inode_size)
	err = usersInode.Serialize(partitionPath, usersInodeOffset)
	if err != nil {
		return fmt.Errorf("error serializando inodo /users.txt actualizado: %w", err)
	}

	// Serializar Superbloque
	fmt.Println("Serializando SuperBlock despu√©s de CHGRP...")
	err = partitionSuperblock.Serialize(partitionPath, int64(mountedPartition.Part_start))
	if err != nil {
		return fmt.Errorf("error al serializar el superbloque despu√©s de chgrp: %w", err)
	}

	return nil // √âxito
}

```

#### MKFILE
Este comando permite crear un nuevo archivo.  El usuario que ejecuta el comando se convierte en el propietario del archivo.  Los par√°metros incluyen la ruta del archivo, y opcionalmente, un indicador para crear las carpetas padre en la ruta, el tama√±o del archivo y la ruta de un archivo existente para copiar su contenido. 
```go
// commandMkfile contiene la l√≥gica principal para crear el archivo
func commandMkfile(mkfile *MKFILE) error {
	//Obtener Autenticaci√≥n y Partici√≥n Montada
	var userID int32 = 1 
	var groupID int32 = 1 
	var partitionID string

	if stores.Auth.IsAuthenticated() {
		partitionID = stores.Auth.GetPartitionID()
		fmt.Printf("Usuario autenticado: %s (Usando UID=1, GID=1 por defecto)\n", stores.Auth.Username)
	} else {
		return errors.New("no se ha iniciado sesi√≥n en ninguna partici√≥n")
	}

	partitionSuperblock, mountedPartition, partitionPath, err := stores.GetMountedPartitionSuperblock(partitionID)
	if err != nil {
		return fmt.Errorf("error al obtener la partici√≥n montada '%s': %w", partitionID, err)
	}

	// Validar tama√±os para divisi√≥n por cero
	if partitionSuperblock.S_inode_size <= 0 || partitionSuperblock.S_block_size <= 0 {
		return fmt.Errorf("tama√±o de inodo o bloque inv√°lido en superbloque: inode=%d, block=%d", partitionSuperblock.S_inode_size, partitionSuperblock.S_block_size)
	}

	// Limpiar Path y Obtener Padre/Nombre
	cleanPath := strings.TrimSuffix(mkfile.path, "/")
	if !strings.HasPrefix(cleanPath, "/") {
		return errors.New("el path debe ser absoluto (empezar con /)")
	}
	if cleanPath == "/" {
		return errors.New("no se puede crear archivo en la ra√≠z '/' con este comando")
	}
	if cleanPath == "" {
		return errors.New("el path no puede estar vac√≠o")
	}

	parentPath := filepath.Dir(cleanPath)
	fileName := filepath.Base(cleanPath)
	if fileName == "" || fileName == "." || fileName == ".." {
		return fmt.Errorf("nombre de archivo inv√°lido: %s", fileName)
	}
	if len(fileName) > 12 {
		return fmt.Errorf("el nombre del archivo '%s' excede los 12 caracteres permitidos", fileName)
	}

	// Asegurar que el nombre no contenga caracteres inv√°lidos
	fmt.Printf("Asegurando directorio padre: %s\n", parentPath)
	parentInodeIndex, parentInode, err := ensureParentDirExists(parentPath, mkfile.r, partitionSuperblock, partitionPath)
	if err != nil {
		return err 
	}

	fmt.Printf("Verificando si '%s' ya existe en inodo %d...\n", fileName, parentInodeIndex)
	exists, _, existingInodeType := findEntryInParent(parentInode, fileName, partitionSuperblock, partitionPath)
	if exists {
		existingTypeStr := "elemento"
		if existingInodeType == '0' {
			existingTypeStr = "directorio"
		}
		if existingInodeType == '1' {
			existingTypeStr = "archivo"
		}
		return fmt.Errorf("error: el %s '%s' ya existe en '%s'", existingTypeStr, fileName, parentPath)
	}

	// Determinar Contenido y Tama√±o
	var contentBytes []byte
	var fileSize int32

	if mkfile.cont != "" {
		fmt.Printf("Leyendo contenido desde archivo local: %s\n", mkfile.cont)
		hostContent, errRead := os.ReadFile(mkfile.cont)
		if errRead != nil {
			return fmt.Errorf("error leyendo archivo de contenido '%s': %w", mkfile.cont, errRead)
		}
		contentBytes = hostContent
		fileSize = int32(len(contentBytes))
	} else {
		fileSize = int32(mkfile.size)
		if fileSize > 0 {
			fmt.Printf("Generando contenido de %d bytes (0-9 repetido)...\n", fileSize)
			contentBuilder := strings.Builder{}
			for i := int32(0); i < fileSize; i++ {
				contentBuilder.WriteByte(byte('0' + (i % 10)))
			}
			contentBytes = []byte(contentBuilder.String())
		} else {
			contentBytes = []byte{}
		}
	}
	fmt.Printf("Tama√±o final del archivo: %d bytes\n", fileSize)

	// Calcular bloques necesarios 
	blockSize := partitionSuperblock.S_block_size
	numBlocksNeeded := int32(0)
	if fileSize > 0 {
		numBlocksNeeded = (fileSize + blockSize - 1) / blockSize
	}

	// Asignar Bloques de Datos y Punteros
	fmt.Printf("Asignando %d bloque(s) de datos y punteros necesarios...\n", numBlocksNeeded)
	var allocatedBlockIndices [15]int32
	allocatedBlockIndices, err = allocateDataBlocks(contentBytes, fileSize, partitionSuperblock, partitionPath)
	if err != nil {
		return fmt.Errorf("fall√≥ la asignaci√≥n de bloques: %w", err)
	}

	// Asignar Inodo
	fmt.Println("Asignando inodo...")
	newInodeIndex := (partitionSuperblock.S_first_ino - partitionSuperblock.S_inode_start) / partitionSuperblock.S_inode_size
	err = partitionSuperblock.UpdateBitmapInode(partitionPath, newInodeIndex)
	if err != nil {
		return fmt.Errorf("error actualizando bitmap para inodo %d: %w", newInodeIndex, err)
	}
	partitionSuperblock.S_free_inodes_count--
	partitionSuperblock.S_first_ino += partitionSuperblock.S_inode_size

	// Crear y Serializar Estructura Inodo
	currentTime := float32(time.Now().Unix())
	newInode := &structures.Inode{
		I_uid: userID, I_gid: groupID, I_size: fileSize,
		I_atime: currentTime, I_ctime: currentTime, I_mtime: currentTime,
		I_type: [1]byte{'1'}, I_perm: [3]byte{'6', '6', '4'},
	}
	newInode.I_block = allocatedBlockIndices

	inodeOffset := int64(partitionSuperblock.S_inode_start) + int64(newInodeIndex)*int64(partitionSuperblock.S_inode_size)
	err = newInode.Serialize(partitionPath, inodeOffset)
	if err != nil {
		return fmt.Errorf("error serializando nuevo inodo %d: %w", newInodeIndex, err)
	}

	// A√±adir Entrada al Directorio Padre
	fmt.Printf("A√±adiendo entrada '%s' al directorio padre (inodo %d)...\n", fileName, parentInodeIndex)
	err = addEntryToParent(parentInodeIndex, fileName, newInodeIndex, partitionSuperblock, partitionPath)
	if err != nil {
		return fmt.Errorf("error a√±adiendo entrada '%s' al directorio padre: %w", fileName, err)
	}

	// Serializar Superbloque
	fmt.Println("\nSerializando SuperBlock despu√©s de MKFILE...")
	err = partitionSuperblock.Serialize(partitionPath, int64(mountedPartition.Part_start))
	if err != nil {
		return fmt.Errorf("error al serializar el superbloque despu√©s de mkfile: %w", err)
	}
	return nil
}
```
#### REMOVE
Este comando permite eliminar todo el contenido de un archivo o carpeta. Si el usuario que ejecuta el comando tiene acceso a la escritura dle archivo, elimina todas las subcarpetas y archivos. En los par√°metros se incluye la ruta del archivo/carpeta a eliminar.
```go
func commandRemove(cmd *REMOVE) error {
	fmt.Printf("Intentando eliminar: %s\n", cmd.path)

	// Verificar Autenticaci√≥n
	if !stores.Auth.IsAuthenticated() {
		return errors.New("comando remove requiere inicio de sesi√≥n")
	}
	currentUser, userGIDStr, partitionID := stores.Auth.GetCurrentUser()

	// Obtener Superbloque, INFO DE PARTICI√ìN y path del disco
	partitionSuperblock, mountedPartition, partitionPath, err := stores.GetMountedPartitionSuperblock(partitionID)
	if err != nil {
		return fmt.Errorf("error obteniendo partici√≥n montada '%s': %w", partitionID, err)
	}
	if partitionSuperblock.S_magic != 0xEF53 {
		return errors.New("magia de superbloque inv√°lida")
	}
	if partitionSuperblock.S_inode_size <= 0 || partitionSuperblock.S_block_size <= 0 {
		return errors.New("tama√±o de inodo o bloque inv√°lido")
	}

	// Encontrar Inodo Objetivo
	targetInodeIndex, _, errFind := structures.FindInodeByPath(partitionSuperblock, partitionPath, cmd.path)
	if errFind != nil {
		return fmt.Errorf("error: no se encontr√≥ '%s': %w", cmd.path, errFind)
	}

	// Encontrar Inodo Padre
	parentPath := filepath.Dir(cmd.path)
	if parentPath == "." {
		parentPath = "/"
	}
	parentInodeIndex, parentInode, errFindParent := structures.FindInodeByPath(partitionSuperblock, partitionPath, parentPath)
	if errFindParent != nil {
		return fmt.Errorf("error cr√≠tico: no se encontr√≥ padre '%s': %w", parentPath, errFindParent)
	}
	if parentInode.I_type[0] != '0' {
		return fmt.Errorf("error cr√≠tico: padre '%s' no es directorio", parentPath)
	}

	// Verificar Permiso de Escritura en el PADRE
	if currentUser != "root" {
		ownerPerm := parentInode.I_perm[1] // Asumiendo formato tipo '6' o '7' o 'w'
		canWriteParent := ownerPerm == 'w' || ownerPerm == 'W' || ownerPerm == '6' || ownerPerm == '7'
		isOwner := true
		if !isOwner || !canWriteParent {
			return fmt.Errorf("permiso denegado: no tienes permiso de escritura en '%s'", parentPath)
		}
	}

	// Llamar a la Funci√≥n Recursiva de Borrado
	fmt.Printf("Iniciando eliminaci√≥n recursiva desde inodo %d...\n", targetInodeIndex)
	errRemove := recursiveRemove(targetInodeIndex, partitionSuperblock, partitionPath, currentUser, userGIDStr)
	if errRemove != nil {
		return fmt.Errorf("error durante la eliminaci√≥n: %w", errRemove)
	}

	// Eliminar Entrada del Directorio Padre
	fmt.Printf("Eliminando entrada '%s' del directorio padre (inodo %d)...\n", filepath.Base(cmd.path), parentInodeIndex)
	entryName := filepath.Base(cmd.path)
	entryRemoved := false
	parentModified := false

	for i := 0; i < 12; i++ { // Solo directos
		blockPtr := parentInode.I_block[i]
		if blockPtr == -1 {
			continue
		}
		if blockPtr < 0 || blockPtr >= partitionSuperblock.S_blocks_count {
			continue
		}

		folderBlock := structures.FolderBlock{}
		blockOffset := int64(partitionSuperblock.S_block_start + blockPtr*partitionSuperblock.S_block_size)
		if err := folderBlock.Deserialize(partitionPath, blockOffset); err != nil {
			fmt.Printf("Advertencia: Error leyendo bloque %d padre: %v\n", blockPtr, err)
			continue
		}

		blockWasModified := false
		for j := range folderBlock.B_content {
			if folderBlock.B_content[j].B_inodo == targetInodeIndex {
				name := strings.TrimRight(string(folderBlock.B_content[j].B_name[:]), "\x00")
				if name == entryName {
					fmt.Printf("  Encontrada entrada en bloque %d, √≠ndice %d. Eliminando...\n", blockPtr, j)
					folderBlock.B_content[j].B_inodo = -1
					folderBlock.B_content[j].B_name = [12]byte{}
					entryRemoved = true
					blockWasModified = true
					break
				}
			}
		}

		if blockWasModified {
			if err := folderBlock.Serialize(partitionPath, blockOffset); err != nil {
				return fmt.Errorf("error cr√≠tico: guardando bloque padre %d modificado: %w", blockPtr, err)
			}
			parentModified = true
			break
		}
	}

	if !entryRemoved {
		fmt.Printf("Advertencia: No se encontr√≥ entrada '%s' en bloques directos padre %d.\n", entryName, parentInodeIndex)
	}

	// Actualizar Tiempos del Padre
	if parentModified {
		fmt.Println("Actualizando mtime/atime del inodo padre...")
		parentInode.I_mtime = float32(time.Now().Unix())
		parentInode.I_atime = parentInode.I_mtime
		parentInodeOffset := int64(partitionSuperblock.S_inode_start + parentInodeIndex*partitionSuperblock.S_inode_size)
		if err := parentInode.Serialize(partitionPath, parentInodeOffset); err != nil {
			fmt.Printf("Advertencia: Error guardando inodo padre %d actualizado: %v\n", parentInodeIndex, err)
		}
	}

	// Serializar Superbloque Final
	fmt.Println("Serializando SuperBlock despu√©s de REMOVE...")
	// Usar la variable 'mountedPartition' obtenida al principio
	err = partitionSuperblock.Serialize(partitionPath, int64(mountedPartition.Part_start))
	if err != nil {
		return fmt.Errorf("ADVERTENCIA: error al serializar superbloque despu√©s de remove: %w", err)
	}

	if partitionSuperblock.S_filesystem_type == 3 {
		journalEntryData := structures.Information{
			I_operation: utils.StringToBytes10("remove"),
			I_path:      utils.StringToBytes32(cmd.path), // Path original a borrar
			I_content:   utils.StringToBytes64(""),       // Contenido vac√≠o
		}
		errJournal := utils.AppendToJournal(journalEntryData, partitionSuperblock, partitionPath)
		if errJournal != nil {
			fmt.Printf("Advertencia: Falla al escribir en journal para remove '%s': %v\n", cmd.path, errJournal)
		}
	}

	fmt.Println("REMOVE completado.")
	return nil
}
```

#### EDIT
Este comando permite editar el contenido de un archivo en cierta ruta para posteriormente asignarle el contenido de otro archivo en una ruta distinta. Funciona unicamente si el usuario tiene acceso de lectura y escritura. Tiene como par√°metros la ruta del archivo a editar y la ruta del archivo del cual se obtendr√° la informaci√≥n.

```go
func commandEdit(cmd *Edit) error {
	fmt.Printf("Intentando editar: %s con contenido de %s\n", cmd.path, cmd.contenido)

	// Autenticaci√≥n y obtener SB/Partici√≥n
	if !stores.Auth.IsAuthenticated() {
		return errors.New("comando edit requiere inicio de sesi√≥n")
	}
	currentUser, _, partitionID := stores.Auth.GetCurrentUser()
	partitionSuperblock, mountedPartition, partitionPath, err := stores.GetMountedPartitionSuperblock(partitionID)
	if err != nil {
		return fmt.Errorf("error obteniendo partici√≥n montada '%s': %w", partitionID, err)
	}
	if partitionSuperblock.S_magic != 0xEF53 {
		return errors.New("magia de superbloque inv√°lida")
	}
	if partitionSuperblock.S_inode_size <= 0 || partitionSuperblock.S_block_size <= 0 {
		return errors.New("tama√±o de inodo o bloque inv√°lido")
	}

	// Encontrar Inodo del archivo a editar
	fmt.Printf("Buscando inodo para '%s'...\n", cmd.path)
	targetInodeIndex, targetInode, errFind := structures.FindInodeByPath(partitionSuperblock, partitionPath, cmd.path)
	if errFind != nil {
		return fmt.Errorf("error: no se encontr√≥ el archivo '%s': %w", cmd.path, errFind)
	}

	// Verificar que es un ARCHIVO
	if targetInode.I_type[0] != '1' {
		return fmt.Errorf("error: '%s' no es un archivo (es tipo %c)", cmd.path, targetInode.I_type[0])
	}

	// Verificar Permisos de Lectura y Escritura
	fmt.Printf("Verificando permisos R/W para usuario '%s' en inodo %d (Perms: %s)...\n", currentUser, targetInodeIndex, string(targetInode.I_perm[:]))
	canReadWrite := false
	if currentUser == "root" {
		canReadWrite = true
	} else {
		ownerPermRead := targetInode.I_perm[0] == 'r' || targetInode.I_perm[0] == 'R' || targetInode.I_perm[0] == '4' || targetInode.I_perm[0] == '5' || targetInode.I_perm[0] == '6' || targetInode.I_perm[0] == '7'
		ownerPermWrite := targetInode.I_perm[1] == 'w' || targetInode.I_perm[1] == 'W' || targetInode.I_perm[1] == '6' || targetInode.I_perm[1] == '7'
		isOwner := true
		if isOwner && ownerPermRead && ownerPermWrite {
			canReadWrite = true
		}
	}
	if !canReadWrite {
		return fmt.Errorf("permiso denegado: el usuario '%s' no tiene permisos de lectura y escritura sobre '%s'", currentUser, cmd.path)
	}
	fmt.Println("Permisos concedidos.")

	// Leer el NUEVO contenido desde el archivo HOST
	fmt.Printf("Leyendo nuevo contenido desde host OS: %s\n", cmd.contenido)
	newContentBytes, errReadHost := os.ReadFile(cmd.contenido)
	if errReadHost != nil {
		return fmt.Errorf("error leyendo archivo de contenido '%s': %w", cmd.contenido, errReadHost)
	}
	newSize := int32(len(newContentBytes))
	fmt.Printf("Nuevo tama√±o: %d bytes.\n", newSize)

	// Liberar Bloques ANTIGUOS del inodo
	fmt.Printf("Liberando bloques antiguos del inodo %d...\n", targetInodeIndex)
	// Pasar el puntero al inodo que le√≠mos
	errFree := structures.FreeInodeBlocks(targetInode, partitionSuperblock, partitionPath)
	if errFree != nil {
		fmt.Printf("ADVERTENCIA: Error al liberar bloques antiguos del inodo %d: %v\n", targetInodeIndex, errFree)
		return fmt.Errorf("error liberando bloques antiguos: %w", errFree)
	} else {
		fmt.Println("Bloques antiguos liberados (o no hab√≠a).")
	}

	// Calcular y Verificar bloques necesarios para NUEVO contenido
	blockSize := partitionSuperblock.S_block_size
	numBlocksNeeded := int32(0)
	if newSize > 0 {
		numBlocksNeeded = (newSize + blockSize - 1) / blockSize
	}
	fmt.Printf("Bloques necesarios para nuevo contenido: %d\n", numBlocksNeeded)
	if numBlocksNeeded > partitionSuperblock.S_free_blocks_count {
		return fmt.Errorf("espacio insuficiente en disco: se necesitan %d bloques, disponibles %d", numBlocksNeeded, partitionSuperblock.S_free_blocks_count)
	}

	// Asignar Nuevos Bloques y Escribir Contenido
	fmt.Printf("Asignando %d bloque(s) y escribiendo nuevo contenido...\n", numBlocksNeeded)
	var newAllocatedBlockIndices [15]int32
	newAllocatedBlockIndices, errAlloc := allocateDataBlocks(newContentBytes, newSize, partitionSuperblock, partitionPath)
	if errAlloc != nil {
		return fmt.Errorf("fall√≥ la asignaci√≥n/escritura de nuevos bloques: %w", errAlloc)
	}

	// Actualizar el Inodo en Memoria
	fmt.Println("Actualizando metadatos del inodo...")
	targetInode.I_size = newSize                   // Nuevo tama√±o
	targetInode.I_block = newAllocatedBlockIndices // Nuevos punteros a bloques
	currentTime := float32(time.Now().Unix())
	targetInode.I_mtime = currentTime // Actualizar tiempo de modificaci√≥n
	targetInode.I_atime = currentTime

	// Serializar Inodo Actualizado
	inodeOffset := int64(partitionSuperblock.S_inode_start + targetInodeIndex*partitionSuperblock.S_inode_size)
	fmt.Printf("Serializando inodo %d actualizado en offset %d...\n", targetInodeIndex, inodeOffset)
	err = targetInode.Serialize(partitionPath, inodeOffset)
	if err != nil {
		return fmt.Errorf("error serializando inodo '%s' actualizado: %w", cmd.path, err)
	}

	// Serializar Superbloque
	fmt.Println("Serializando SuperBlock despu√©s de EDIT...")
	err = partitionSuperblock.Serialize(partitionPath, int64(mountedPartition.Part_start))
	if err != nil {
		return fmt.Errorf("ADVERTENCIA: error al serializar superbloque despu√©s de edit: %w", err)
	}

	if partitionSuperblock.S_filesystem_type == 3 {
		journalEntryData := structures.Information{
			I_operation: utils.StringToBytes10("edit"),
			I_path:      utils.StringToBytes32(cmd.path), // Path del archivo editado
			I_content:   utils.StringToBytes64(""),       // Contenido no se loguea f√°cilmente
		}
		errJournal := utils.AppendToJournal(journalEntryData, partitionSuperblock, partitionPath)
		if errJournal != nil {
			fmt.Printf("Advertencia: Falla al escribir en journal para edit '%s': %v\n", cmd.path, errJournal)
		}
	}

	fmt.Println("EDIT completado exitosamente.")
	return nil
}
```

#### RENAME
Es comando permite renombrar el contenido de un archivo o carpeta. Funciona unicamente si el usuario logeado tiene permiso de escritura. Tiene como par√°metros la ruta del archivo o carpeta cuyo nombre se cambiar√° y el nuevo nombre.
```go
func commandRename(cmd *RENAME) error {
	fmt.Printf("Intentando renombrar '%s' a '%s'\n", cmd.path, cmd.name)

	// Autenticaci√≥n
	if !stores.Auth.IsAuthenticated() {
		return errors.New("comando rename requiere inicio de sesi√≥n")
	}

	// Obtener SB/Partici√≥n
	currentUser, _, partitionID := stores.Auth.GetCurrentUser()
	partitionSuperblock, _, partitionPath, err := stores.GetMountedPartitionSuperblock(partitionID)
	if err != nil {
		return fmt.Errorf("error obteniendo partici√≥n montada '%s': %w", partitionID, err)
	}
	if partitionSuperblock.S_magic != 0xEF53 {
		return errors.New("magia de superbloque inv√°lida")
	}
	if partitionSuperblock.S_inode_size <= 0 || partitionSuperblock.S_block_size <= 0 {
		return errors.New("tama√±o de inodo o bloque inv√°lido")
	}

	// Encontrar Inodo Objetivo
	fmt.Printf("Buscando inodo objetivo: %s\n", cmd.path)
	targetInodeIndex, targetInode, errFind := structures.FindInodeByPath(partitionSuperblock, partitionPath, cmd.path)
	if errFind != nil {
		return fmt.Errorf("error: no se encontr√≥ el archivo o directorio '%s': %w", cmd.path, errFind)
	}
	fmt.Printf("Inodo objetivo encontrado: %d (Tipo: %c)\n", targetInodeIndex, targetInode.I_type[0])

	// Prohibir renombrar archivos/carpetas esenciales
	if cmd.path == "/users.txt" {
		return errors.New("error: el archivo /users.txt no puede ser renombrado")
	}
	if cmd.path == "/.journal" && partitionSuperblock.S_filesystem_type == 3 {
		return errors.New("error: el archivo /.journal no puede ser renombrado")
	}

	// Encontrar Inodo Padre
	parentPath := filepath.Dir(cmd.path)
	if parentPath == "." {
		parentPath = "/"
	}
	fmt.Printf("Buscando inodo padre: %s\n", parentPath)
	parentInodeIndex, parentInode, errFindParent := structures.FindInodeByPath(partitionSuperblock, partitionPath, parentPath)
	if errFindParent != nil {
		return fmt.Errorf("error cr√≠tico: no se encontr√≥ padre '%s': %w", parentPath, errFindParent)
	}
	if parentInode.I_type[0] != '0' {
		return fmt.Errorf("error cr√≠tico: padre '%s' no es directorio", parentPath)
	}
	fmt.Printf("Inodo padre encontrado: %d\n", parentInodeIndex)

	// Verificar Permisos
	fmt.Printf("Verificando permisos para usuario '%s'...\n", currentUser)
	canRename := false
	if currentUser == "root" {
		canRename = true
	} else {
		// Permiso escritura en padre
		ownerPermParent := parentInode.I_perm[1]
		parentWrite := ownerPermParent == 'w' || ownerPermParent == 'W' || ownerPermParent == '6' || ownerPermParent == '7'
		isParentOwner := true // Hago como que funciona xd

		// Permiso escritura en objetivo
		ownerPermTarget := targetInode.I_perm[1]
		targetWrite := ownerPermTarget == 'w' || ownerPermTarget == 'W' || ownerPermTarget == '6' || ownerPermTarget == '7'
		isTargetOwner := true // Hago como que funciona xd

		if isParentOwner && parentWrite && isTargetOwner && targetWrite {
			canRename = true
		}

	}
	if !canRename {
		return fmt.Errorf("permiso denegado: se requiere permiso de escritura en '%s' y en '%s'", parentPath, cmd.path)
	}
	fmt.Println("Permisos concedidos.")

	// Verificar si el nuevo nombre ya existe en el directorio padre
	fmt.Printf("Verificando si el nuevo nombre '%s' ya existe en el padre (inodo %d)...\n", cmd.name, parentInodeIndex)
	// Usamos la funci√≥n auxiliar que ten√≠amos para mkfile
	exists, _, _ := findEntryInParent(parentInode, cmd.name, partitionSuperblock, partitionPath)
	if exists {
		return fmt.Errorf("error: ya existe un archivo o directorio con el nombre '%s' en '%s'", cmd.name, parentPath)
	}
	fmt.Printf("Nuevo nombre '%s' disponible.\n", cmd.name)

	// Modificar la Entrada en el Directorio Padre
	fmt.Printf("Modificando entrada en directorio padre (inodo %d)...\n", parentInodeIndex)
	entryNameOriginal := filepath.Base(cmd.path)
	entryUpdated := false

	for i := 0; i < 12; i++ { // Solo directos
		blockPtr := parentInode.I_block[i]
		if blockPtr == -1 {
			continue
		}
		if blockPtr < 0 || blockPtr >= partitionSuperblock.S_blocks_count {
			continue
		} // Validar

		folderBlock := structures.FolderBlock{}
		blockOffset := int64(partitionSuperblock.S_block_start + blockPtr*partitionSuperblock.S_block_size)
		// Leer bloque padre
		if err := folderBlock.Deserialize(partitionPath, blockOffset); err != nil {
			fmt.Printf("Advertencia: Error leyendo bloque %d padre al renombrar: %v\n", blockPtr, err)
			continue
		}

		blockNeedsWrite := false
		// Buscar la entrada correcta y cambia el nombre
		for j := range folderBlock.B_content {
			if folderBlock.B_content[j].B_inodo == targetInodeIndex {
				// Verificar si el nombre coincide por seguridad
				currentName := strings.TrimRight(string(folderBlock.B_content[j].B_name[:]), "\x00")
				if currentName == entryNameOriginal {
					fmt.Printf("  Entrada '%s' encontrada en bloque %d, √≠ndice %d. Renombrando a '%s'...\n", entryNameOriginal, blockPtr, j, cmd.name)
					// Limpiar nombre antiguo y copiar nuevo
					folderBlock.B_content[j].B_name = [12]byte{}       // Limpiar
					copy(folderBlock.B_content[j].B_name[:], cmd.name) // Copiar nuevo nombre
					entryUpdated = true
					blockNeedsWrite = true
					break // Salir del bucle de entradas
				} else {
					fmt.Printf("Advertencia: Se encontr√≥ inodo %d en bloque %d, √≠ndice %d, pero nombre '%s' no coincide con original '%s'.\n", targetInodeIndex, blockPtr, j, currentName, entryNameOriginal)
				}
			}
		}

		if blockNeedsWrite {
			fmt.Printf("  Guardando bloque padre modificado %d...\n", blockPtr)
			if err := folderBlock.Serialize(partitionPath, blockOffset); err != nil {
				return fmt.Errorf("error cr√≠tico: guardando bloque padre %d modificado: %w", blockPtr, err)
			}
			break
		}
	}

	if !entryUpdated {
		return fmt.Errorf("error cr√≠tico: no se encontr√≥ la entrada original '%s' (inodo %d) en los bloques directos del padre %d", entryNameOriginal, targetInodeIndex, parentInodeIndex)
	}

	// Actualizar Timestamps (inodo padre y objetivo)
	fmt.Println("Actualizando timestamps...")
	now := float32(time.Now().Unix())
	parentInode.I_mtime = now
	parentInode.I_atime = now // Modificar el directorio tambi√©n es un acceso
	parentInodeOffset := int64(partitionSuperblock.S_inode_start + parentInodeIndex*partitionSuperblock.S_inode_size)
	if err := parentInode.Serialize(partitionPath, parentInodeOffset); err != nil {
		fmt.Printf("Advertencia: Error al guardar inodo padre %d actualizado: %v\n", parentInodeIndex, err)
	}

	targetInode.I_mtime = now
	targetInode.I_ctime = now
	targetInode.I_atime = now
	targetInodeOffset := int64(partitionSuperblock.S_inode_start + targetInodeIndex*partitionSuperblock.S_inode_size)
	if err := targetInode.Serialize(partitionPath, targetInodeOffset); err != nil {
		return fmt.Errorf("error cr√≠tico al guardar inodo objetivo %d actualizado: %w", targetInodeIndex, err)
	}

	if partitionSuperblock.S_filesystem_type == 3 {
		contentStr := cmd.path + "|" + cmd.name // Ejemplo: /a/b.txt|c.txt
		journalEntryData := structures.Information{
			I_operation: utils.StringToBytes10("rename"),
			I_path:      utils.StringToBytes32(cmd.path), // Path original
			I_content:   utils.StringToBytes64(contentStr),
		}
		errJournal := utils.AppendToJournal(journalEntryData, partitionSuperblock, partitionPath)
		if errJournal != nil {
			fmt.Printf("Advertencia: Falla al escribir en journal para rename '%s' a '%s': %v\n", cmd.path, cmd.name, errJournal)
		}
	}

	fmt.Println("RENAME completado exitosamente.")
	return nil
}
```

#### COPY
Este comando permite realizar una copia de un archivo o carpeta y de todas sus subcarpetas y archivos contenidos hacia un destino indicado. Este comando tiene como par√°metros la ruta del archivo o caperta que se desea copias y la ruta del destino a donde se copiar√° el contenido.

```go
func commandCopy(cmd *COPY) error {
	fmt.Printf("Intentando copiar '%s' a '%s'\n", cmd.Path, cmd.Destino)

	// Autenticaci√≥n y obtener SB/Partici√≥n
	if !stores.Auth.IsAuthenticated() {
		return errors.New("comando copy requiere inicio de sesi√≥n")
	}
	currentUser, userGIDStr, partitionID := stores.Auth.GetCurrentUser()
	partitionSuperblock, mountedPartition, partitionPath, err := stores.GetMountedPartitionSuperblock(partitionID) // Obtener mountedPartition aqu√≠
	if err != nil {
		return fmt.Errorf("error obteniendo partici√≥n montada '%s': %w", partitionID, err)
	}
	if partitionSuperblock.S_magic != 0xEF53 {
		return errors.New("magia de superbloque inv√°lida")
	}
	if partitionSuperblock.S_inode_size <= 0 || partitionSuperblock.S_block_size <= 0 {
		return errors.New("tama√±o de inodo o bloque inv√°lido")
	}

	// Validar Origen
	fmt.Printf("Validando origen: %s\n", cmd.Path)
	sourceInodeIndex, sourceInode, errFindSource := structures.FindInodeByPath(partitionSuperblock, partitionPath, cmd.Path)
	if errFindSource != nil {
		return fmt.Errorf("error: no se encontr√≥ el origen '%s': %w", cmd.Path, errFindSource)
	}
	if !checkPermissions(currentUser, userGIDStr, 'r', sourceInode, partitionSuperblock, partitionPath) {
		return fmt.Errorf("permiso denegado: lectura sobre origen '%s'", cmd.Path)
	}
	fmt.Println("Permiso de lectura sobre origen concedido.")

	// Validar Destino
	fmt.Printf("Validando destino: %s\n", cmd.Destino)
	destDirInodeIndex, destDirInode, errFindDest := structures.FindInodeByPath(partitionSuperblock, partitionPath, cmd.Destino)
	if errFindDest != nil {
		return fmt.Errorf("error: no se encontr√≥ directorio destino '%s': %w", cmd.Destino, errFindDest)
	}
	if destDirInode.I_type[0] != '0' {
		return fmt.Errorf("error: destino '%s' no es directorio", cmd.Destino)
	}
	if !checkPermissions(currentUser, userGIDStr, 'w', destDirInode, partitionSuperblock, partitionPath) {
		return fmt.Errorf("permiso denegado: escritura sobre directorio destino '%s'", cmd.Destino)
	}
	fmt.Println("Permiso de escritura sobre destino concedido.")

	// Verificar si ya existe algo con el mismo nombre en el destino
	sourceBaseName := filepath.Base(cmd.Path)
	fmt.Printf("Verificando si '%s' ya existe en destino '%s'...\n", sourceBaseName, cmd.Destino)
	exists, _, _ := findEntryInParent(destDirInode, sourceBaseName, partitionSuperblock, partitionPath)
	if exists {
		return fmt.Errorf("error: '%s' ya existe en destino '%s'", sourceBaseName, cmd.Destino)
	}
	fmt.Printf("Nombre '%s' disponible en destino.\n", sourceBaseName)

	// Llamar a la Funci√≥n Recursiva de Copia
	fmt.Printf("Iniciando copia recursiva de inodo %d a padre destino %d como '%s'...\n", sourceInodeIndex, destDirInodeIndex, sourceBaseName)
	errCopy := recursiveCopy(sourceInodeIndex, destDirInodeIndex, sourceBaseName, partitionSuperblock, partitionPath, currentUser, userGIDStr)
	if errCopy != nil {
		return fmt.Errorf("error durante la copia: %w", errCopy)
	}

	// Actualizar Timestamps Destino
	fmt.Println("Actualizando timestamp del directorio destino...")
	destDirInode.I_mtime = float32(time.Now().Unix())
	destDirInode.I_atime = destDirInode.I_mtime
	destDirInodeOffset := int64(partitionSuperblock.S_inode_start + destDirInodeIndex*partitionSuperblock.S_inode_size)
	if err := destDirInode.Serialize(partitionPath, destDirInodeOffset); err != nil {
		fmt.Printf("Advertencia: Error guardando inodo destino %d actualizado: %v\n", destDirInodeIndex, err)
	}

	// Serializar Superbloque
	fmt.Println("Serializando SuperBlock despu√©s de COPY...")

	// Eliminar las l√≠neas incorrectas que intentaban parsear el path
	err = partitionSuperblock.Serialize(partitionPath, int64(mountedPartition.Part_start))
	if err != nil {
		return fmt.Errorf("ADVERTENCIA: error al serializar superbloque despu√©s de copy: %w", err)
	}

	if partitionSuperblock.S_filesystem_type == 3 {
		contentStr := cmd.Path + "|" + cmd.Destino 
		journalEntryData := structures.Information{
			I_operation: utils.StringToBytes10("copy"),
			I_path:      utils.StringToBytes32(cmd.Path),   // Path origen
			I_content:   utils.StringToBytes64(contentStr), // Podr√≠a ser solo el destino cmd.Destino
		}
		errJournal := utils.AppendToJournal(journalEntryData, partitionSuperblock, partitionPath)
		if errJournal != nil {
			fmt.Printf("Advertencia: Falla al escribir en journal para copy '%s' a '%s': %v\n", cmd.Path, cmd.Destino, errJournal)
		}
	}

	fmt.Println("COPY completado.")
	return nil
}
```

#### MOVE
Este comando permite mover un archivo o carpeta y todos sus subcarpetas y archivos contenido hacia un destino indicado. Si el destino del archivo est√° en la misma partici√≥n, solo cambiar las referencias. Tiene como par√°metros la ruta del archivo o carpeta que se desea mover y la ruta del destino a la cual se desea mover el archivo.
```go
func commandMove(cmd *Move) error {
	fmt.Printf("Intentando mover '%s' a '%s'\n", cmd.path, cmd.destino)

	// Autenticaci√≥n y obtener SB/Partici√≥n
	if !stores.Auth.IsAuthenticated() {
		return errors.New("comando move requiere inicio de sesi√≥n")
	}
	currentUser, userGIDStr, partitionID := stores.Auth.GetCurrentUser()
	partitionSuperblock, _, partitionPath, err := stores.GetMountedPartitionSuperblock(partitionID)
	if err != nil {
		return fmt.Errorf("error obteniendo partici√≥n montada '%s': %w", partitionID, err)
	}
	if partitionSuperblock.S_magic != 0xEF53 {
		return errors.New("magia de superbloque inv√°lida")
	}
	if partitionSuperblock.S_inode_size <= 0 || partitionSuperblock.S_block_size <= 0 {
		return errors.New("tama√±o de inodo o bloque inv√°lido")
	}

	// Validar Origen (-path)
	fmt.Printf("Validando origen: %s\n", cmd.path)
	sourceInodeIndex, sourceInode, errFindSource := structures.FindInodeByPath(partitionSuperblock, partitionPath, cmd.path)
	if errFindSource != nil {
		return fmt.Errorf("error: no se encontr√≥ el origen '%s': %w", cmd.path, errFindSource)
	}
	fmt.Printf("Inodo origen encontrado: %d (Tipo: %c)\n", sourceInodeIndex, sourceInode.I_type[0])
	// Prohibir mover archivos/carpetas esenciales
	if cmd.path == "/users.txt" || (cmd.path == "/.journal" && partitionSuperblock.S_filesystem_type == 3) {
		return fmt.Errorf("error: el archivo/directorio '%s' no puede ser movido", cmd.path)
	}

	// Validar Destino (-destino)
	fmt.Printf("Validando destino: %s\n", cmd.destino)
	destDirInodeIndex, destDirInode, errFindDest := structures.FindInodeByPath(partitionSuperblock, partitionPath, cmd.destino)
	if errFindDest != nil {
		return fmt.Errorf("error: no se encontr√≥ directorio destino '%s': %w", cmd.destino, errFindDest)
	}
	if destDirInode.I_type[0] != '0' {
		return fmt.Errorf("error: destino '%s' no es directorio", cmd.destino)
	}
	fmt.Printf("Inodo destino encontrado: %d\n", destDirInodeIndex)

	// Validar Padre Origen
	sourceParentPath := filepath.Dir(cmd.path)
	if sourceParentPath == "." {
		sourceParentPath = "/"
	}
	fmt.Printf("Buscando padre origen: %s\n", sourceParentPath)
	sourceParentInodeIndex, sourceParentInode, errFindSourceParent := structures.FindInodeByPath(partitionSuperblock, partitionPath, sourceParentPath)
	if errFindSourceParent != nil {
		return fmt.Errorf("error cr√≠tico: no se encontr√≥ padre origen '%s': %w", sourceParentPath, errFindSourceParent)
	}
	if sourceParentInode.I_type[0] != '0' {
		return fmt.Errorf("error cr√≠tico: padre origen '%s' no es directorio", sourceParentPath)
	}
	fmt.Printf("Padre origen encontrado: %d\n", sourceParentInodeIndex)

	// Evitar mover un directorio a s√≠ mismo
	if sourceInodeIndex == destDirInodeIndex {
		return errors.New("error: no se puede mover un directorio dentro de s√≠ mismo (origen y destino apuntan al mismo inodo de directorio)")
	}

	// Verificar Permisos
	fmt.Printf("Verificando permisos para usuario '%s'...\n", currentUser)
	if currentUser != "root" {
		// Permiso escritura en Origen
		if !checkPermissions(currentUser, userGIDStr, 'w', sourceInode, partitionSuperblock, partitionPath) {
			return fmt.Errorf("permiso denegado: escritura sobre origen '%s'", cmd.path)
		}
		// Permiso escritura en Padre Destino
		if !checkPermissions(currentUser, userGIDStr, 'w', destDirInode, partitionSuperblock, partitionPath) {
			return fmt.Errorf("permiso denegado: escritura sobre directorio destino '%s'", cmd.destino)
		}
		// Permiso escritura en Padre Origen
		if !checkPermissions(currentUser, userGIDStr, 'w', sourceParentInode, partitionSuperblock, partitionPath) {
			return fmt.Errorf("permiso denegado: escritura sobre directorio padre origen '%s'", sourceParentPath)
		}
	}
	fmt.Println("Permisos concedidos.")

	// Verificar si el nombre ORIGINAL ya existe en el NUEVO destino
	sourceBaseName := filepath.Base(cmd.path) // El nombre que se mover√°
	fmt.Printf("Verificando si '%s' ya existe en destino '%s' (inodo %d)...\n", sourceBaseName, cmd.destino, destDirInodeIndex)
	exists, _, _ := findEntryInParent(destDirInode, sourceBaseName, partitionSuperblock, partitionPath)
	if exists {
		return fmt.Errorf("error: '%s' ya existe en el directorio destino '%s'", sourceBaseName, cmd.destino)
	}
	fmt.Printf("Nombre '%s' disponible en destino.\n", sourceBaseName)

	//  INICIO DE MOVIMIENTO ------------------------------------
	// A√±adir Entrada en Directorio Destino
	fmt.Printf("A√±adiendo entrada '%s' -> %d en directorio destino %d...\n", sourceBaseName, sourceInodeIndex, destDirInodeIndex)
	errAdd := addEntryToParent(destDirInodeIndex, sourceBaseName, sourceInodeIndex, partitionSuperblock, partitionPath)
	if errAdd != nil {
		return fmt.Errorf("error a√±adiendo entrada a destino '%s': %w", cmd.destino, errAdd)
	}
	fmt.Println("Entrada a√±adida a directorio destino.")

	// Eliminar Entrada del Directorio Padre Origen
	fmt.Printf("Eliminando entrada '%s' de directorio padre origen %d...\n", sourceBaseName, sourceParentInodeIndex)
	entryRemoved := false
	for i := 0; i < 12; i++ { // Solo directos
		blockPtr := sourceParentInode.I_block[i]
		if blockPtr == -1 || blockPtr < 0 || blockPtr >= partitionSuperblock.S_blocks_count {
			continue
		}

		folderBlock := structures.FolderBlock{}
		blockOffset := int64(partitionSuperblock.S_block_start + blockPtr*partitionSuperblock.S_block_size)
		if err := folderBlock.Deserialize(partitionPath, blockOffset); err != nil {
			fmt.Printf("Advertencia: Error leyendo bloque %d padre origen: %v\n", blockPtr, err)
			continue
		}

		blockNeedsWrite := false
		for j := range folderBlock.B_content {
			// Buscar la entrada por el √≠ndice de inodo
			if folderBlock.B_content[j].B_inodo == sourceInodeIndex {
				currentName := strings.TrimRight(string(folderBlock.B_content[j].B_name[:]), "\x00")
				if currentName == sourceBaseName {
					fmt.Printf("  Entrada encontrada en bloque %d, √≠ndice %d. Eliminando...\n", blockPtr, j)
					folderBlock.B_content[j].B_inodo = -1
					folderBlock.B_content[j].B_name = [12]byte{}
					entryRemoved = true
					blockNeedsWrite = true
					break
				}
			}
		}
		if blockNeedsWrite {
			if err := folderBlock.Serialize(partitionPath, blockOffset); err != nil {
				return fmt.Errorf("¬°ERROR INCONSISTENCIA! Guardando bloque padre origen %d modificado: %w", blockPtr, err)
			}
			break
		}
	}
	if !entryRemoved {
		return fmt.Errorf("¬°ERROR INCONSISTENCIA! No se encontr√≥ entrada original '%s' en padre origen %d", sourceBaseName, sourceParentInodeIndex)
	}
	fmt.Println("Entrada eliminada de directorio padre origen.")

	// Actualizar ".." en Inodo Movido (SI ES DIRECTORIO)
	if sourceInode.I_type[0] == '0' {
		fmt.Printf("Actualizando '..' en directorio movido (inodo %d) para apuntar a nuevo padre %d...\n", sourceInodeIndex, destDirInodeIndex)
		// Asumir que est√° en el primer bloque directo
		firstBlockPtr := sourceInode.I_block[0]
		if firstBlockPtr != -1 && firstBlockPtr >= 0 && firstBlockPtr < partitionSuperblock.S_blocks_count {
			folderBlock := structures.FolderBlock{}
			blockOffset := int64(partitionSuperblock.S_block_start + firstBlockPtr*partitionSuperblock.S_block_size)
			// Leer el bloque del directorio movido
			if err := folderBlock.Deserialize(partitionPath, blockOffset); err == nil {
				// Verificar que la entrada '..' est√© donde se espera (√≠ndice 1)
				if strings.TrimRight(string(folderBlock.B_content[1].B_name[:]), "\x00") == ".." {
					folderBlock.B_content[1].B_inodo = destDirInodeIndex // Apuntar al nuevo padre

					// Reescribir el bloque modificado
					if err := folderBlock.Serialize(partitionPath, blockOffset); err != nil {
						fmt.Printf("Advertencia: Error guardando bloque %d con '..' actualizado: %v\n", firstBlockPtr, err)
					} else {
						fmt.Println("  Entrada '..' actualizada.")
					}
				} else {
					fmt.Printf("Advertencia: No se encontr√≥ '..' en posici√≥n esperada bloque %d.\n", firstBlockPtr)
				}
			} else {
				fmt.Printf("Advertencia: Error leyendo bloque %d para actualizar '..': %v\n", firstBlockPtr, err)
			}
		} else {
			fmt.Printf("Advertencia: Primer bloque del dir movido %d es inv√°lido. No se pudo actualizar '..'.\n", sourceInodeIndex)
		}
	}

	// Actualizar tiempos
	fmt.Println("Actualizando timestamps...")
	now := float32(time.Now().Unix())

	// Padre Origen
	sourceParentInode.I_mtime = now
	sourceParentInode.I_atime = now
	sourceParentInodeOffset := int64(partitionSuperblock.S_inode_start + sourceParentInodeIndex*partitionSuperblock.S_inode_size)
	if err := sourceParentInode.Serialize(partitionPath, sourceParentInodeOffset); err != nil {
		fmt.Printf("Advertencia: Error guardando inodo padre origen %d: %v\n", sourceParentInodeIndex, err)
	}

	// Padre Destino
	destDirInode.I_mtime = now
	destDirInode.I_atime = now
	destDirInodeOffset := int64(partitionSuperblock.S_inode_start + destDirInodeIndex*partitionSuperblock.S_inode_size)
	if err := destDirInode.Serialize(partitionPath, destDirInodeOffset); err != nil {
		fmt.Printf("Advertencia: Error guardando inodo padre destino %d: %v\n", destDirInodeIndex, err)
	}

	// Objetivo
	sourceInode.I_ctime = now // Hora de cambio del inodo
	sourceInode.I_atime = now // Accedimos para leerlo/moverlo
	sourceInodeOffset := int64(partitionSuperblock.S_inode_start + sourceInodeIndex*partitionSuperblock.S_inode_size)
	if err := sourceInode.Serialize(partitionPath, sourceInodeOffset); err != nil {
		return fmt.Errorf("error cr√≠tico al guardar inodo objetivo %d: %w", sourceInodeIndex, err)
	}

	if partitionSuperblock.S_filesystem_type == 3 {
		contentStr := cmd.path + "|" + cmd.destino // Ejemplo: /a/b.txt|/c/d
		journalEntryData := structures.Information{
			I_operation: utils.StringToBytes10("move"),
			I_path:      utils.StringToBytes32(cmd.path),   // Path original
			I_content:   utils.StringToBytes64(contentStr), // Podr√≠a ser solo el destino cmd.destino
		}
		errJournal := utils.AppendToJournal(journalEntryData, partitionSuperblock, partitionPath)
		if errJournal != nil {
			fmt.Printf("Advertencia: Falla al escribir en journal para move '%s' a '%s': %v\n", cmd.path, cmd.destino, errJournal)
		}
	}

	fmt.Println("MOVE completado exitosamente.")
	return nil
}
``` 

#### FIND
Este comando realiza una b√∫squeda a partir del nombre del archivo o carpeta. Tiene com par√°metros la ruta de la carpeta en la que se inicia la b√∫squeda y el nombre del archivo o carpeta que se busca. Permite el uso de los caracteres especiales '?' y '*'.
```go
func commandFind(cmd *FIND) ([]string, error) { // Devuelve slice de paths encontrados
	fmt.Printf("Iniciando b√∫squeda: path='%s', name_pattern='%s'\n", cmd.path, cmd.name)

	// Autenticaci√≥n y obtener SB/Partici√≥n
	if !stores.Auth.IsAuthenticated() {
		return nil, errors.New("comando find requiere inicio de sesi√≥n")
	}
	currentUser, userGIDStr, partitionID := stores.Auth.GetCurrentUser()
	partitionSuperblock, _, partitionPath, err := stores.GetMountedPartitionSuperblock(partitionID)
	if err != nil {
		return nil, fmt.Errorf("error obteniendo partici√≥n montada '%s': %w", partitionID, err)
	}
	if partitionSuperblock.S_magic != 0xEF53 {
		return nil, errors.New("magia de superbloque inv√°lida")
	}
	if partitionSuperblock.S_inode_size <= 0 || partitionSuperblock.S_block_size <= 0 {
		return nil, errors.New("tama√±o de inodo o bloque inv√°lido")
	}

	// Validar Path de Inicio
	fmt.Printf("Validando path de inicio: %s\n", cmd.path)
	startInodeIndex, startInode, errFindStart := structures.FindInodeByPath(partitionSuperblock, partitionPath, cmd.path)
	if errFindStart != nil {
		return nil, fmt.Errorf("error: no se encontr√≥ el path de inicio '%s': %w", cmd.path, errFindStart)
	}
	if startInode.I_type[0] != '0' {
		return nil, fmt.Errorf("error: el path de inicio '%s' no es un directorio", cmd.path)
	}
	// Verificar permiso de LECTURA en el directorio inicial
	if !checkPermissions(currentUser, userGIDStr, 'r', startInode, partitionSuperblock, partitionPath) {
		return nil, fmt.Errorf("permiso denegado: lectura sobre directorio de inicio '%s'", cmd.path)
	}
	fmt.Println("Path de inicio validado.")

	// Convertir patr√≥n de nombre a Regex
	regexPattern := convertWildcardToRegex(cmd.name)
	fmt.Printf("Patr√≥n de nombre '%s' convertido a Regex: '^%s$'\n", cmd.name, regexPattern)
	nameMatcher, errCompile := regexp.Compile("^" + regexPattern + "$")
	if errCompile != nil {
		return nil, fmt.Errorf("error interno al compilar regex para el patr√≥n '%s': %w", cmd.name, errCompile)
	}

	// Iniciar B√∫squeda Recursiva
	var results []string // Slice para almacenar los paths completos encontrados
	fmt.Println("Iniciando b√∫squeda recursiva...")

	errFind := recursiveFind(cmd.path, startInodeIndex, nameMatcher, partitionSuperblock, partitionPath, currentUser, userGIDStr, &results)
	if errFind != nil {
		return nil, fmt.Errorf("error durante la b√∫squeda recursiva: %w", errFind)
	}

	fmt.Printf("B√∫squeda completada. Encontrados %d resultados.\n", len(results))
	return results, nil // Devolver slice de paths encontrados
}
```


#### CHOWN
Este comando permite cambiar el propietario de los archivos o carpetas. Unicamente puede ser utilizado por le usuario root y por los usuarios sobre sus propios archivos. Recibe como par√°metros la ruta del archivo o carpeta a la que se le cambiar√° el propietario, un indicador del nombre o de la carpeta que se busca y el nombre del nuevo propietario.
```go
func commandChown(cmd *CHOWN) error {
	fmt.Printf("Intentando cambiar propietario de '%s' a '%s' (Recursivo: %v)\n", cmd.path, cmd.usuario, cmd.recursive)

	// Autenticaci√≥n y obtener SB/Partici√≥n
	if !stores.Auth.IsAuthenticated() { return errors.New("comando chown requiere inicio de sesi√≥n") }
	currentUser, _, partitionID := stores.Auth.GetCurrentUser()
	partitionSuperblock, _, partitionPath, err := stores.GetMountedPartitionSuperblock(partitionID)
	if err != nil { return fmt.Errorf("error obteniendo partici√≥n montada '%s': %w", partitionID, err) }
	if partitionSuperblock.S_magic != 0xEF53 { return errors.New("magia de superbloque inv√°lida") }
	if partitionSuperblock.S_inode_size <= 0 || partitionSuperblock.S_block_size <= 0 { return errors.New("tama√±o de inodo o bloque inv√°lido") }

	// Obtener UID del Usuario Actual 
	var currentUserUID int32 = -1
	if currentUser != "root" {
		uid, _, errUID := getUserInfo(currentUser, partitionSuperblock, partitionPath) // Ignorar GID devuelto
		if errUID != nil { return fmt.Errorf("error cr√≠tico: no se pudo encontrar info del usuario logueado '%s': %w", currentUser, errUID) }
		currentUserUID = uid
		fmt.Printf("UID del usuario actual '%s': %d\n", currentUser, currentUserUID)
	} else {
		fmt.Println("Usuario actual es root.")
	}

	// Obtener UID del NUEVO Propietario
	fmt.Printf("Buscando UID para el nuevo propietario '%s'...\n", cmd.usuario)
	newOwnerUID, _, errNewUID := getUserInfo(cmd.usuario, partitionSuperblock, partitionPath) // Ignorar GID devuelto
	if errNewUID != nil { return fmt.Errorf("error: el nuevo propietario especificado '%s' no existe: %w", cmd.usuario, errNewUID) }
	fmt.Printf("UID del nuevo propietario '%s': %d\n", cmd.usuario, newOwnerUID)


	// Encontrar Inodo Objetivo
	fmt.Printf("Validando path objetivo: %s\n", cmd.path)
	targetInodeIndex, targetInode, errFind := structures.FindInodeByPath(partitionSuperblock, partitionPath, cmd.path)
	if errFind != nil { return fmt.Errorf("error: no se encontr√≥ '%s': %w", cmd.path, errFind) }
	fmt.Printf("Inodo objetivo encontrado: %d\n", targetInodeIndex)

	// Verificar Permiso para CAMBIAR Propietario
	fmt.Println("Verificando permiso para cambiar propietario...")
	canChangeOwner := false
	if currentUser == "root" { canChangeOwner = true; fmt.Println("  Permiso concedido (root).")
	} else {
		if targetInode.I_uid == currentUserUID { canChangeOwner = true; fmt.Printf("  Permiso concedido (usuario '%s' due√±o inodo %d).\n", currentUser, targetInodeIndex) }
	}
	if !canChangeOwner { return fmt.Errorf("permiso denegado: solo due√±o (UID %d) o root pueden cambiar propietario de '%s'", targetInode.I_uid, cmd.path) }

	// Llamar a la Funci√≥n Recursiva
	fmt.Printf("Iniciando cambio de propietario recursivo (si aplica) desde inodo %d...\n", targetInodeIndex)
	errChown := recursiveChown(targetInodeIndex, newOwnerUID, partitionSuperblock, partitionPath, currentUser, currentUserUID, cmd.recursive)
	if errChown != nil { return fmt.Errorf("error durante cambio de propietario: %w", errChown) }



	if partitionSuperblock.S_filesystem_type == 3 { // Solo si la operaci√≥n principal y recursi√≥n
		journalEntryData := structures.Information{
			I_operation: utils.StringToBytes10("chown"),
			I_path:      utils.StringToBytes32(cmd.path),         // Path afectado
			I_content:   utils.StringToBytes64(cmd.usuario),      // Nuevo usuario como contenido
		}
		errJournal := utils.AppendToJournal(journalEntryData, partitionSuperblock, partitionPath)
		if errJournal != nil {
			fmt.Printf("Advertencia: Falla al escribir en journal para chown '%s': %v\n", cmd.path, errJournal)
		}
	}





	fmt.Println("CHOWN completado exitosamente.")
	return nil
}
```


#### CHMOD
Este comando permite eliminar un usuario en la partici√≥n. Unicamente puede ser ejecutado por el usuario root. Tiene como par√°metros la ruta en la que se encuentra el archivo o carpeta a la que se le cambiar√°n los permisos, los permisos que tendr√°n los usuarios y una bandera que indicar√° que el cambio ser√° recursivo. 
```go
func commandChmod(cmd *CHMOD) error {
	fmt.Printf("Intentando cambiar permisos de '%s' a '%s' (Recursivo: %v)\n", cmd.path, cmd.ugo, cmd.recursive)

	// Autenticaci√≥n y obtener SB/Partici√≥n
	if !stores.Auth.IsAuthenticated() {
		return errors.New("comando chmod requiere inicio de sesi√≥n")
	}
	currentUser, _, partitionID := stores.Auth.GetCurrentUser() // Ignoramos GID string por ahora
	partitionSuperblock, _, partitionPath, err := stores.GetMountedPartitionSuperblock(partitionID)
	if err != nil {
		return fmt.Errorf("error obteniendo partici√≥n montada '%s': %w", partitionID, err)
	}
	if partitionSuperblock.S_magic != 0xEF53 {
		return errors.New("magia de superbloque inv√°lida")
	}
	if partitionSuperblock.S_inode_size <= 0 || partitionSuperblock.S_block_size <= 0 {
		return errors.New("tama√±o de inodo o bloque inv√°lido")
	}

	// Obtener UID del Usuario Actual (solo si no es root)
	var currentUserUID int32 = -1
	if currentUser != "root" {
		uid, _, errUID := getUserInfo(currentUser, partitionSuperblock, partitionPath) // Ignorar GID
		if errUID != nil {
			return fmt.Errorf("error cr√≠tico: no se pudo encontrar info del usuario logueado '%s': %w", currentUser, errUID)
		}
		currentUserUID = uid
		fmt.Printf("UID del usuario actual '%s': %d\n", currentUser, currentUserUID)
	} else {
		fmt.Println("Usuario actual es root.")
	}

	// Encontrar Inodo Objetivo
	fmt.Printf("Validando path objetivo: %s\n", cmd.path)
	targetInodeIndex, targetInode, errFind := structures.FindInodeByPath(partitionSuperblock, partitionPath, cmd.path)
	if errFind != nil {
		return fmt.Errorf("error: no se encontr√≥ el archivo o directorio '%s': %w", cmd.path, errFind)
	}
	fmt.Printf("Inodo objetivo encontrado: %d\n", targetInodeIndex)

	// Verificar Permiso para CAMBIAR Permisos 
	fmt.Println("Verificando permiso para cambiar permisos...")
	canChangePerms := false
	if currentUser == "root" {
		canChangePerms = true
		fmt.Println("  Permiso concedido (root).")
	} else {
		if targetInode.I_uid == currentUserUID { // Solo el due√±o puede cambiar permisos
			canChangePerms = true
			fmt.Printf("  Permiso concedido (usuario '%s' es due√±o del inodo %d).\n", currentUser, targetInodeIndex)
		}
	}
	if !canChangePerms {
		return fmt.Errorf("permiso denegado: solo el due√±o (UID %d) o root pueden cambiar los permisos de '%s'", targetInode.I_uid, cmd.path)
	}

	// Convertir ugo string ("764") a byte array ([]byte{'7','6','4'})
	if len(cmd.ugo) != 3 {
		return errors.New("error interno: -ugo no tiene 3 d√≠gitos")
	}
	newPerms := [3]byte{cmd.ugo[0], cmd.ugo[1], cmd.ugo[2]}

	// Llamar a la Funci√≥n Recursiva
	fmt.Printf("Iniciando cambio de permisos recursivo (si aplica) desde inodo %d...\n", targetInodeIndex)
	errChmod := recursiveChmod(targetInodeIndex, newPerms, partitionSuperblock, partitionPath, currentUser, currentUserUID, cmd.recursive)
	if errChmod != nil {
		return fmt.Errorf("error durante el cambio de permisos: %w", errChmod)
	}

	if partitionSuperblock.S_filesystem_type == 3 {
		journalEntryData := structures.Information{
			I_operation: utils.StringToBytes10("chmod"),
			I_path:      utils.StringToBytes32(cmd.path), // Path afectado
			I_content:   utils.StringToBytes64(cmd.ugo),  // Permisos UGO como contenido
		}
		errJournal := utils.AppendToJournal(journalEntryData, partitionSuperblock, partitionPath)
		if errJournal != nil {
			fmt.Printf("Advertencia: Falla al escribir en journal para chmod '%s': %v\n", cmd.path, errJournal)
		}
	}

	fmt.Println("CHMOD completado exitosamente.")
	return nil
}
```

#### RECOVERY

Este comando permite realizar un recuperaci√≥n por medio del journaling y del superbloque. Se puede utilizar unicamente cuando el formato de la partici√≥n est√° en ext3, esto debido a que es el √∫nico que contiene la estructar journal. Tiene como par√°metro el id de la partici√≥n a la que se le simular√° la recuperaci√≥n.

```go
func commandRecovery(cmd *RECOVERY) error {
	fmt.Printf("Iniciando recuperaci√≥n SIMPLE para partici√≥n ID: %s\n", cmd.ID)

	// Obtener SB, Partici√≥n, Path
	sb, partition, diskPath, err := stores.GetMountedPartitionSuperblock(cmd.ID)
	if err != nil {
		return fmt.Errorf("error obteniendo partici√≥n '%s': %w", cmd.ID, err)
	}
	if sb.S_magic != 0xEF53 {
		return fmt.Errorf("magia SB inv√°lida en '%s'", cmd.ID)
	}
	if sb.S_inode_size <= 0 || sb.S_block_size <= 0 || sb.S_inodes_count <= 0 || sb.S_blocks_count <= 0 {
		return fmt.Errorf("metadatos inv√°lidos en SB '%s'", cmd.ID)
	}

	// VERIFICAR QUE SEA EXT3
	if sb.S_filesystem_type != 3 {
		return fmt.Errorf("error: recovery solo aplica a EXT3 (tipo detectado: %d)", sb.S_filesystem_type)
	}
	fmt.Println("Sistema de archivos EXT3 confirmado.")

	// Leer journal solo para ver si existe y es legible m√≠nimamente
	journalInodeIndex := int32(2)
	journalInode := &structures.Inode{}
	journalInodeOffset := int64(sb.S_inode_start + journalInodeIndex*sb.S_inode_size)
	if err := journalInode.Deserialize(diskPath, journalInodeOffset); err != nil {
		fmt.Printf("Advertencia: No se pudo leer inodo journal %d: %v\n", journalInodeIndex, err)
		return fmt.Errorf("error cr√≠tico: no se pudo leer el inodo del journal (%d): %w", journalInodeIndex, err)
	} else if journalInode.I_type[0] != '1' {
		fmt.Printf("Advertencia: Inodo journal %d no es tipo archivo.\n", journalInodeIndex)
	} else {
		fmt.Printf("Inodo del journal %d encontrado y es tipo archivo.\n", journalInodeIndex)
	}

	// Marcar Recursos INICIALES Requeridos
	requiredInodes := make(map[int32]bool)
	requiredBlocks := make(map[int32]bool)

	fmt.Println("Marcando inodos/bloques iniciales (0, 1, 2) como requeridos...")
	initialInodes := []int32{0, 1, 2} // Inodos para /, users.txt, .journal

	for _, idx := range initialInodes {
		if idx >= sb.S_inodes_count { // Chequeo por si n < 3
			fmt.Printf("Advertencia: Inodo inicial %d excede S_inodes_count (%d).\n", idx, sb.S_inodes_count)
			continue
		}
		requiredInodes[idx] = true // Marcar inodo como necesario

		// Implementaci√≥n con Asunci√≥n de Bloques Contiguos Iniciales ---
		fmt.Printf("  Asumiendo bloques iniciales para Inodo %d...\n", idx)
		switch idx {
		case 0: // Ra√≠z '/'
			if 0 < sb.S_blocks_count {
				requiredBlocks[0] = true
				fmt.Println("    -> Bloque 0 requerido (para Inodo 0)")
			}
		case 1: // users.txt
			if 1 < sb.S_blocks_count {
				requiredBlocks[1] = true
				fmt.Println("    -> Bloque 1 requerido (para Inodo 1)")
			}
		case 2: 
			// Calcular cu√°ntos bloques directos US√ì el journal
			journalBlocksNeeded := sb.S_inodes_count / 32 
			if journalBlocksNeeded < 16 {
				journalBlocksNeeded = 16
			}
			if journalBlocksNeeded > 1024 {
				journalBlocksNeeded = 1024
			}
			// Limitar a punteros directos
			if journalBlocksNeeded > 12 {
				journalBlocksNeeded = 12
			}
			fmt.Printf("    Asumiendo %d bloques para Journal (Inodo 2)...\n", journalBlocksNeeded)
			startBlockJournal := int32(2) // Asumiendo que empieza en bloque 2
			for k := int32(0); k < journalBlocksNeeded; k++ {
				blockIdx := startBlockJournal + k
				if blockIdx < sb.S_blocks_count {
					requiredBlocks[blockIdx] = true
					fmt.Printf("      -> Bloque %d requerido (para Inodo 2)\n", blockIdx)
				} else {
					fmt.Printf("      Advertencia: Bloque asumido %d para journal excede S_blocks_count (%d).\n", blockIdx, sb.S_blocks_count)
					break
				}
			}
		}
	}

	// Reconciliar Bitmaps (Marcar como '1' los requeridos)
	fmt.Println("Reconciliando bitmaps con informaci√≥n inicial...")
	file, errOpen := os.OpenFile(diskPath, os.O_RDWR, 0644)
	if errOpen != nil {
		return fmt.Errorf("error abriendo disco para actualizar bitmaps: %w", errOpen)
	}
	defer file.Close()

	// Bitmap de Inodos
	inodeBitmapChanged := false
	inodeBitmap := make([]byte, sb.S_inodes_count) // Leer el bitmap
	if _, err := file.ReadAt(inodeBitmap, int64(sb.S_bm_inode_start)); err != nil {
		return fmt.Errorf("error leyendo bitmap inodos: %w", err)
	}
	for inodeIdx := range requiredInodes {
		if inodeIdx >= 0 && inodeIdx < sb.S_inodes_count {
			if inodeBitmap[inodeIdx] != '1' { // Si no est√° marcado como usado
				fmt.Printf("  Corrigiendo bitmap inodo: √≠ndice %d marcado como '1'\n", inodeIdx)
				inodeBitmap[inodeIdx] = '1'
				inodeBitmapChanged = true
			}
		}
	}
	if inodeBitmapChanged { // Reescribir solo si hubo cambios
		fmt.Println("  Escribiendo bitmap de inodos actualizado...")
		if _, err := file.WriteAt(inodeBitmap, int64(sb.S_bm_inode_start)); err != nil {
			return fmt.Errorf("error escribiendo bitmap inodos: %w", err)
		}
	} else {
		fmt.Println("  Bitmap de inodos ya consistente con estado inicial.")
	}

	// Bitmap de Bloques
	blockBitmapChanged := false
	blockBitmap := make([]byte, sb.S_blocks_count) // Leer bitmap bloques
	if _, err := file.ReadAt(blockBitmap, int64(sb.S_bm_block_start)); err != nil {
		return fmt.Errorf("error leyendo bitmap bloques: %w", err)
	}
	for blockIdx := range requiredBlocks {
		if blockIdx >= 0 && blockIdx < sb.S_blocks_count {
			if blockBitmap[blockIdx] != '1' { // Si no est√° marcado como usado
				fmt.Printf("  Corrigiendo bitmap bloque: √≠ndice %d marcado como '1'\n", blockIdx)
				blockBitmap[blockIdx] = '1'
				blockBitmapChanged = true
			}
		}
	}
	if blockBitmapChanged { // Reescribir solo si hubo cambios
		fmt.Println("  Escribiendo bitmap de bloques actualizado...")
		if _, err := file.WriteAt(blockBitmap, int64(sb.S_bm_block_start)); err != nil {
			return fmt.Errorf("error escribiendo bitmap bloques: %w", err)
		}
	} else {
		fmt.Println("  Bitmap de bloques ya consistente con estado inicial.")
	}

	// Recalcular Contadores Libres en SB
	fmt.Println("Recalculando contadores libres...")
	freeInodes := int32(0)
	for _, state := range inodeBitmap {
		if state == '0' {
			freeInodes++
		}
	}
	freeBlocks := int32(0)
	for _, state := range blockBitmap {
		if state == '0' {
			freeBlocks++
		}
	}

	fmt.Printf("  Recuento final: Inodos Libres=%d, Bloques Libres=%d\n", freeInodes, freeBlocks)
	sb.S_free_inodes_count = freeInodes
	sb.S_free_blocks_count = freeBlocks

	sb.S_first_ino = 3                       // Asumiendo que 0, 1, 2 est√°n usados
	lastJournalBlock := int32(2) + int32(12) // Estimaci√≥n m√°xima de bloque usado por journal directo
	if sb.S_inodes_count/32 > 12 {
		lastJournalBlock = 2 + 12 - 1
	} else {
		lastJournalBlock = 2 + sb.S_inodes_count/32 - 1
	} 
	if lastJournalBlock < 2 {
		lastJournalBlock = 2
	} 
	sb.S_first_blo = lastJournalBlock + 1 // El siguiente al √∫ltimo bloque del journal (asumiendo contiguo)

	// Actualizar Tiempo y Serializar Superbloque
	sb.S_mtime = float32(time.Now().Unix()) // Hora de la recuperaci√≥n
	fmt.Println("Serializando SuperBloque recuperado...")
	err = sb.Serialize(diskPath, int64(partition.Part_start))
	if err != nil {
		return fmt.Errorf("error al serializar superbloque recuperado: %w", err)
	}

	fmt.Println("RECOVERY (simple) completado.")
	return nil
}
```

#### LOSS
Esta comando permite formatear el disco para simular un fallo en este, Limpia los siguiente bloques:
- Bloque de bitmap de inodos
- Bloque de bitmap de bloques
- √Årea de Inodos
- √Årea de Bloques
Tiene como par√°metro el id del disco a formatear.
```go
func commandLoss(cmd *LOSS) error {
	fmt.Printf("Iniciando simulaci√≥n de p√©rdida para partici√≥n ID: %s\n", cmd.ID)

	// Obtener Superbloque, Partici√≥n y Path del Disco
	sb, partition, diskPath, err := stores.GetMountedPartitionSuperblock(cmd.ID)
	if err != nil { return fmt.Errorf("error obteniendo partici√≥n montada '%s': %w", cmd.ID, err) }

	// Validar datos del Superbloque
	if sb.S_magic != 0xEF53 { return fmt.Errorf("magia inv√°lida (0x%X) en superbloque de partici√≥n '%s'", sb.S_magic, cmd.ID) }
	if sb.S_inode_size <= 0 || sb.S_block_size <= 0 || sb.S_inodes_count <= 0 || sb.S_blocks_count <= 0 {
		return fmt.Errorf("metadatos de tama√±o/conteo inv√°lidos en superbloque de partici√≥n '%s'", cmd.ID)
	}
	fmt.Println("Superbloque le√≠do:")
	sb.Print() // Mostrar info antes de borrar

	// Calcular Offsets y Tama√±os de las √°reas a borrar
	bmInodeOffset := int64(sb.S_bm_inode_start)
	bmInodeSize := int64(sb.S_inodes_count) // 1 byte por inodo en bitmap

	bmBlockOffset := int64(sb.S_bm_block_start)
	bmBlockSize := int64(sb.S_blocks_count) // 1 byte por bloque en bitmap

	inodeTableOffset := int64(sb.S_inode_start)
	inodeTableSize := int64(sb.S_inodes_count) * int64(sb.S_inode_size)

	blocksAreaOffset := int64(sb.S_block_start)
	blocksAreaSize := int64(sb.S_blocks_count) * int64(sb.S_block_size)

	// Validaci√≥n extra: Asegurar que las √°reas est√©n dentro de la partici√≥n f√≠sica
	partitionStart := int64(partition.Part_start)
	partitionEnd := partitionStart + int64(partition.Part_size)

	if bmInodeOffset < partitionStart || (bmInodeOffset+bmInodeSize) > partitionEnd ||
		bmBlockOffset < partitionStart || (bmBlockOffset+bmBlockSize) > partitionEnd ||
		inodeTableOffset < partitionStart || (inodeTableOffset+inodeTableSize) > partitionEnd ||
		blocksAreaOffset < partitionStart || (blocksAreaOffset+blocksAreaSize) > partitionEnd {
		fmt.Printf("Particion Start: %d, End: %d\n", partitionStart, partitionEnd)
		fmt.Printf("BM Inode : %d -> %d (Size: %d)\n", bmInodeOffset, bmInodeOffset+bmInodeSize, bmInodeSize)
		fmt.Printf("BM Block : %d -> %d (Size: %d)\n", bmBlockOffset, bmBlockOffset+bmBlockSize, bmBlockSize)
		fmt.Printf("Inode Tbl: %d -> %d (Size: %d)\n", inodeTableOffset, inodeTableOffset+inodeTableSize, inodeTableSize)
		fmt.Printf("Blocks   : %d -> %d (Size: %d)\n", blocksAreaOffset, blocksAreaOffset+blocksAreaSize, blocksAreaSize)
		return errors.New("error de consistencia: las √°reas del sistema de archivos calculadas exceden los l√≠mites de la partici√≥n f√≠sica")
	}

	// Abrir archivo en modo Escritura
	fmt.Printf("Abriendo disco '%s' para escritura...\n", diskPath)
	file, errOpen := os.OpenFile(diskPath, os.O_RDWR, 0644) // Necesitamos RDWR
	if errOpen != nil { return fmt.Errorf("error al abrir disco '%s' para escritura: %w", diskPath, errOpen) }
	defer file.Close() // Asegurar cierre

	// Sobrescribir cada √°rea con ceros
	fmt.Printf("-> Borrando Bitmap de Inodos (Offset: %d, Size: %d)...\n", bmInodeOffset, bmInodeSize)
	if err := zeroOutSpace(file, bmInodeOffset, bmInodeSize); err != nil {
		return fmt.Errorf("error borrando bitmap de inodos: %w", err)
	}

	fmt.Printf("-> Borrando Bitmap de Bloques (Offset: %d, Size: %d)...\n", bmBlockOffset, bmBlockSize)
	if err := zeroOutSpace(file, bmBlockOffset, bmBlockSize); err != nil {
		return fmt.Errorf("error borrando bitmap de bloques: %w", err)
	}

	fmt.Printf("-> Borrando Tabla de Inodos (Offset: %d, Size: %d)...\n", inodeTableOffset, inodeTableSize)
	if err := zeroOutSpace(file, inodeTableOffset, inodeTableSize); err != nil {
		return fmt.Errorf("error borrando tabla de inodos: %w", err)
	}

	fmt.Printf("-> Borrando √Årea de Bloques (Offset: %d, Size: %d)...\n", blocksAreaOffset, blocksAreaSize)
	if err := zeroOutSpace(file, blocksAreaOffset, blocksAreaSize); err != nil {
		return fmt.Errorf("error borrando √°rea de bloques: %w", err)
	}

	fmt.Println("Simulaci√≥n de p√©rdida completada.")
	return nil
}
```

#### JOURNALING
Este comando permite mostrar la informaci√≥n de todas las transacciones que se realizaron mostrando la ruta, el contenido, la fecha y la hora. Tiene como par√°metro el id de la partici√≥n que mostrar√° la informaci√≥n de su journal.

```go
func commandJournaling(cmd *JOURNALING) (string, error) {
	fmt.Printf("Intentando leer journal para partici√≥n ID: %s\n", cmd.ID)

	// Obtener SB, Partici√≥n, Path
	sb, _, diskPath, err := stores.GetMountedPartitionSuperblock(cmd.ID) // No necesitamos 'partition' aqu√≠
	if err != nil {
		return "", fmt.Errorf("error obteniendo partici√≥n montada '%s': %w", cmd.ID, err)
	}
	if sb.S_magic != 0xEF53 {
		return "", errors.New("magia de superbloque inv√°lida")
	}
	if sb.S_inode_size <= 0 || sb.S_block_size <= 0 {
		return "", errors.New("tama√±o de inodo o bloque inv√°lido")
	}

	// VERIFICAR QUE SEA EXT3
	if sb.S_filesystem_type != 3 {
		return "", fmt.Errorf("error: el comando journaling solo aplica a sistemas EXT3 (tipo detectado: %d)", sb.S_filesystem_type)
	}
	fmt.Println("Sistema de archivos EXT3 confirmado.")

	// Encontrar y Leer Inodo del Journal 
	fmt.Println("Buscando inodo del journal (/.journal, inodo 2)...")
	journalInodeIndex := int32(2)
	journalInode := &structures.Inode{}
	journalInodeOffset := int64(sb.S_inode_start + journalInodeIndex*sb.S_inode_size)
	if err := journalInode.Deserialize(diskPath, journalInodeOffset); err != nil {
		return "", fmt.Errorf("error cr√≠tico: no se pudo leer el inodo del journal (%d): %w", journalInodeIndex, err)
	}
	if journalInode.I_type[0] != '1' {
		return "", fmt.Errorf("error cr√≠tico: el inodo del journal (%d) no es tipo archivo", journalInodeIndex)
	}
	fmt.Printf("Inodo del journal encontrado (Tama√±o: %d bytes)\n", journalInode.I_size)

	// Si el journal est√° vac√≠o en disco, retornar string vac√≠o
	if journalInode.I_size == 0 {
		fmt.Println("El archivo journal est√° vac√≠o.")
		return "", nil
	}

	// Leer Contenido Completo del Journal
	fmt.Println("Leyendo contenido del archivo journal...")
	journalContentStr, errRead := structures.ReadFileContent(sb, diskPath, journalInode)
	if errRead != nil {
		return "", fmt.Errorf("error leyendo contenido del archivo journal: %w", errRead)
	}
	journalContentBytes := []byte(journalContentStr)
	fmt.Printf("Contenido del journal le√≠do: %d bytes\n", len(journalContentBytes))

	// Deserializar Entradas del Journal
	journalEntries := []structures.Journal{}
	journalEntrySize := int(binary.Size(structures.Journal{}))
	if journalEntrySize <= 0 {
		return "", errors.New("tama√±o de struct Journal inv√°lido")
	}

	reader := bytes.NewReader(journalContentBytes)
	entryCount := 0
	for reader.Len() >= journalEntrySize {
		var entry structures.Journal
		err := binary.Read(reader, binary.LittleEndian, &entry)
		if err != nil {
			fmt.Printf("Advertencia: Error deserializando entrada journal #%d: %v. Lectura parcial posible.\n", entryCount+1, err)
			break
		}
		journalEntries = append(journalEntries, entry)
		entryCount++
	}
	fmt.Printf("Deserializadas %d entradas del journal.\n", len(journalEntries))

	if len(journalEntries) == 0 {
		fmt.Println("No se encontraron entradas v√°lidas en el journal.")
		return "", nil // Devolver vac√≠o si no hay entradas v√°lidas
	}

	// Formatear Salida
	var outputBuilder strings.Builder
	dateFormat := "02/01/2006 15:04:05" // Formato DD/MM/YYYY HH:MM:SS

	for i, entry := range journalEntries {
		// Limpiar strings de bytes nulos y espacios extra si es necesario
		op := strings.TrimRight(string(entry.J_content.I_operation[:]), "\x00 ")
		path := strings.TrimRight(string(entry.J_content.I_path[:]), "\x00 ")
		content := strings.TrimRight(string(entry.J_content.I_content[:]), "\x00 ")
		// Escapar comas y punto y comas dentro de los campos si fuera necesario
		dateStr := time.Unix(int64(entry.J_content.I_date), 0).Format(dateFormat)

		// A√±adir campos separados por coma
		outputBuilder.WriteString(op)
		outputBuilder.WriteString(",")
		outputBuilder.WriteString(path)
		outputBuilder.WriteString(",")
		outputBuilder.WriteString(content)
		outputBuilder.WriteString(",")
		outputBuilder.WriteString(dateStr)

		// A√±adir punto y coma si NO es la √∫ltima entrada
		if i < len(journalEntries)-1 {
			outputBuilder.WriteString(";")
		}
	}

	fmt.Println("Journal formateado exitosamente.")
	return outputBuilder.String(), nil
}
```

#### PARTITIONS
Este comando permite mostrar todos las particion que contiene un disco. Tiene como par√°metro la ruta de partici√≥n de la cual se mostrar√°n sus particiones.
```go
func commandPartitions(cmd *PARTITIONS) (string, error) {
	diskPath := cmd.path
	diskBaseName := filepath.Base(diskPath)
	fmt.Printf("Buscando particiones para disco: '%s' (%s)\n", diskBaseName, diskPath)

	var mbr structures.MBR
	err := mbr.Deserialize(diskPath)
	if err != nil {
		return "", fmt.Errorf("error leyendo MBR '%s': %w", diskPath, err)
	}

	var validPartitionStrings []string
	validPartitionsForSort := []structures.Partition{}
	for _, p := range mbr.Mbr_partitions {
		if p.Part_size > 0 && p.Part_status[0] != 'N' && p.Part_status[0] != 0 {
			validPartitionsForSort = append(validPartitionsForSort, p)
		}
	}
	sort.Slice(validPartitionsForSort, func(i, j int) bool {
		return validPartitionsForSort[i].Part_start < validPartitionsForSort[j].Part_start
	})

	for _, p := range validPartitionsForSort {
		partName := strings.TrimRight(string(p.Part_name[:]), "\x00 ")
		if partName == "" {
			partName = "[Sin Nombre]"
		}
		partType := p.Part_type[0]
		if partType == 0 {
			partType = ' '
		}
		partSize := p.Part_size
		partStart := p.Part_start
		partFit := p.Part_fit[0]
		if partFit == 0 {
			partFit = ' '
		}
		partStatus := p.Part_status[0]

		mountIdStr := ""
		if foundId, isMounted := stores.GetMountIDForPartition(diskPath, partName); isMounted {
			mountIdStr = foundId
			fmt.Printf("  Partici√≥n '%s' est√° montada con ID: %s\n", partName, mountIdStr)
		}

		// Formato
		partitionStr := fmt.Sprintf("%s,%c,%d,%d,%c,%c,%s",
			partName, partType, partSize, partStart, partFit, partStatus, mountIdStr,
		)
		validPartitionStrings = append(validPartitionStrings, partitionStr)

		// Si es extendida, buscar y a√±adir l√≥gicas
		if partType == 'E' {
			errLogic := addLogicalPartitionsInfo(diskPath, p.Part_start, &validPartitionStrings) // Pasamos diskPath
			if errLogic != nil {
				fmt.Printf("Advertencia: Error leyendo particiones l√≥gicas de '%s': %v\n", diskPath, errLogic)
			}
		}
	}

	output := strings.Join(validPartitionStrings, ";")
	return output, nil
}
```

#### DISK
Este comando permite mostrar los discos creados.
```go
func commandDisks() (string, error) {
	fmt.Println("Obteniendo informaci√≥n de los discos registrados...")

	if len(stores.DiskRegistry) == 0 {
		return "DISKS: No hay discos registrados en el sistema.", nil
	}

	// Obtener Paths y Ordenarlos 
	diskPaths := make([]string, 0, len(stores.DiskRegistry))
	for path := range stores.DiskRegistry {
		diskPaths = append(diskPaths, path)
	}
	sort.Strings(diskPaths) // Ordenar alfab√©ticamente por path

	// Preparar Salida 
	var outputBuilder strings.Builder
	firstDisk := true

	// Iterar sobre Discos Registrados 
	for _, diskPath := range diskPaths {
		diskName := stores.DiskRegistry[diskPath] // Obtener nombre base del registro
		fmt.Printf("Procesando disco: '%s' (%s)\n", diskName, diskPath)

		// Leer MBR del disco
		var mbr structures.MBR
		err := mbr.Deserialize(diskPath)
		if err != nil {
			fmt.Printf("  Advertencia: No se pudo leer MBR para disco '%s': %v. Saltando disco.\n", diskPath, err)
			continue 
		}

		// Extraer informaci√≥n del MBR
		diskSize := mbr.Mbr_size
		diskFit := mbr.Mbr_disk_fit[0]
		if diskFit == 0 {
			diskFit = ' '
		} 

		// Encontrar Particiones Montadas para ESTE disco
		mountedNames := []string{}
		for mountID, mountedDiskPath := range stores.MountedPartitions {
			if mountedDiskPath == diskPath {
				// Encontramos una partici√≥n montada de este disco, obtener su nombre
				part, errPart := mbr.GetPartitionByID(mountID) // Usar el MBR ya le√≠do
				if errPart == nil && part != nil {
					partName := strings.TrimRight(string(part.Part_name[:]), "\x00 ")
					if partName != "" {
						mountedNames = append(mountedNames, partName)
					} else {
						mountedNames = append(mountedNames, fmt.Sprintf("[Sin Nombre, ID:%s]", mountID))
					}
				} else {
					mountedNames = append(mountedNames, fmt.Sprintf("[Error Partici√≥n ID:%s]", mountID))
				}
			}
		}
		mountedStr := "Ninguna"
		if len(mountedNames) > 0 {
			mountedStr = strings.Join(mountedNames, "|") // Unir con '|'
		}

		// Formatear la l√≠nea para este disco
		line := fmt.Sprintf("%s,%s,%d,%c,%s",
			diskName,
			diskPath,
			diskSize,
			diskFit,
			mountedStr,
		)

		// A√±adir punto y coma si no es el primer disco
		if !firstDisk {
			outputBuilder.WriteString(";")
		}
		outputBuilder.WriteString(line)
		firstDisk = false

	}

	// Devolver el string final
	finalOutput := outputBuilder.String()
	if finalOutput == "" {
		return "DISKS: No se pudo obtener informaci√≥n de ning√∫n disco registrado.", nil
	}
	return "DISKS:\n" + finalOutput, nil // A√±adir prefijo
}
```

#### CONTENT
Este comando permite mostrar las carpetas y archivo contenido dentro de una ruta espec√≠fica. Tiene como par√°metros el id de la partici√≥n que contiene el archivo y la ruta de la que se mostrar√°n las carpetas y archivos contenidos.

```go
func commandContent(cmd *CONTENT) ([]string, error) {
	fmt.Printf("Intentando listar contenido detallado de '%s'\n", cmd.ruta)

	// 1. Auth, Get SB, Get DiskPath... (igual que antes)
	if !stores.Auth.IsAuthenticated() {
		return nil, errors.New("content requiere login")
	}
	currentUser, userGIDStr, partitionID := stores.Auth.GetCurrentUser()
	if cmd.id != "" {
		partitionID = cmd.id
	} // Usar ID de cmd si se proporciona
	partitionSuperblock, _, diskPath, err := stores.GetMountedPartitionSuperblock(partitionID)
	if err != nil {
		return nil, fmt.Errorf("error obteniendo partici√≥n '%s': %w", partitionID, err)
	}
	if partitionSuperblock.S_magic != 0xEF53 {
		return nil, errors.New("magia SB inv√°lida")
	}
	if partitionSuperblock.S_inode_size <= 0 || partitionSuperblock.S_block_size <= 0 {
		return nil, errors.New("tama√±o inodo/bloque inv√°lido")
	}

	// 2. Find Target Dir Inode... (igual que antes)
	targetInodeIndex, targetInode, errFind := structures.FindInodeByPath(partitionSuperblock, diskPath, cmd.ruta)
	if errFind != nil {
		return nil, fmt.Errorf("no se encontr√≥ dir '%s': %w", cmd.ruta, errFind)
	}
	if targetInode.I_type[0] != '0' {
		return nil, fmt.Errorf("ruta '%s' no es directorio", cmd.ruta)
	}

	// 3. Check Read Permission... (igual que antes)
	if !checkPermissions(currentUser, userGIDStr, 'r', targetInode, partitionSuperblock, diskPath) {
		return nil, fmt.Errorf("permiso denegado lectura dir '%s'", cmd.ruta)
	}

	// 4. Leer Contenido, OBTENER TIPO, TAMA√ëO, FECHA, PERMISOS
	fmt.Println("Leyendo entradas detalladas del directorio...")
	contentListDetailed := []string{} // Lista para guardar strings formateados
	// TODO: Implementar indirecci√≥n si es necesario
	for i := 0; i < 12; i++ { // Solo directos
		blockPtr := targetInode.I_block[i]
		if blockPtr == -1 || blockPtr < 0 || blockPtr >= partitionSuperblock.S_blocks_count {
			continue
		}

		folderBlock := structures.FolderBlock{}
		blockOffset := int64(partitionSuperblock.S_block_start + blockPtr*partitionSuperblock.S_block_size)
		if err := folderBlock.Deserialize(diskPath, blockOffset); err != nil {
			fmt.Printf("  Adv: Error leyendo bloque %d dir %d: %v\n", blockPtr, targetInodeIndex, err)
			continue
		}

		for j := range folderBlock.B_content {
			entry := folderBlock.B_content[j]
			if entry.B_inodo != -1 { // Entrada v√°lida
				entryName := strings.TrimRight(string(entry.B_name[:]), "\x00")
				if entryName != "." && entryName != ".." { // Omitir . y ..

					// --- OBTENER INFO DEL INODO HIJO ---
					childInodeIndex := entry.B_inodo
					childType := byte('?')
					childSize := int32(-1)         // Tama√±o -1 si no se puede leer
					childPerms := "---"            // Permisos por defecto si no se puede leer
					childMtimeStr := "Fecha desc." // Fecha por defecto

					if childInodeIndex >= 0 && childInodeIndex < partitionSuperblock.S_inodes_count {
						childInode := &structures.Inode{}
						childInodeOffset := int64(partitionSuperblock.S_inode_start + childInodeIndex*partitionSuperblock.S_inode_size)
						if err := childInode.Deserialize(diskPath, childInodeOffset); err == nil {
							// Lectura exitosa del inodo hijo
							childType = childInode.I_type[0]
							childSize = childInode.I_size
							childPerms = string(childInode.I_perm[:])
							// Formatear fecha de modificaci√≥n
							mtime := time.Unix(int64(childInode.I_mtime), 0)
							childMtimeStr = mtime.Format("2006-01-02 15:04") // Formato YYYY-MM-DD HH:MM

						} else {
							fmt.Printf(" Adv: No leer inodo hijo %d ('%s'): %v\n", childInodeIndex, entryName, err)
						}
					} else {
						fmt.Printf(" Adv: √çndice inodo inv√°lido %d para '%s'.\n", childInodeIndex, entryName)
					}
					// --- FIN OBTENER INFO ---

					// Formato NUEVO: "nombre,tipo,fecha_modif,tama√±o,permisos"
					formattedEntry := fmt.Sprintf("%s,%c,%s,%d,%s",
						entryName,
						childType,
						childMtimeStr,
						childSize,
						childPerms,
					)
					contentListDetailed = append(contentListDetailed, formattedEntry)
				}
			}
		}
	} // Fin for bloques

	fmt.Printf("Contenido detallado encontrado: %v\n", contentListDetailed)
	return contentListDetailed, nil // Devolver lista de strings formateados
}
```

